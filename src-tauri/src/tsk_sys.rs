/* automatically generated by rust-bindgen 0.72.1 */

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(improper_ctypes)]

pub const TSK_VERSION_NUM: u32 = 68419839;
pub const TSK_VERSION_STR: &[u8; 15] = b"4.15.0-develop\0";
pub const TSK_ERROR_STRING_MAX_LENGTH: u32 = 1024;
pub const TSK_ERR_AUX: u32 = 16777216;
pub const TSK_ERR_IMG: u32 = 33554432;
pub const TSK_ERR_VS: u32 = 67108864;
pub const TSK_ERR_FS: u32 = 134217728;
pub const TSK_ERR_HDB: u32 = 268435456;
pub const TSK_ERR_AUTO: u32 = 536870912;
pub const TSK_ERR_POOL: u32 = 1073741824;
pub const TSK_ERR_MASK: u32 = 16777215;
pub const TSK_ERR_AUX_MALLOC: u32 = 16777216;
pub const TSK_ERR_AUX_GENERIC: u32 = 16777218;
pub const TSK_ERR_AUX_MAX: u32 = 2;
pub const TSK_ERR_IMG_NOFILE: u32 = 33554432;
pub const TSK_ERR_IMG_OFFSET: u32 = 33554433;
pub const TSK_ERR_IMG_UNKTYPE: u32 = 33554434;
pub const TSK_ERR_IMG_UNSUPTYPE: u32 = 33554435;
pub const TSK_ERR_IMG_OPEN: u32 = 33554436;
pub const TSK_ERR_IMG_STAT: u32 = 33554437;
pub const TSK_ERR_IMG_SEEK: u32 = 33554438;
pub const TSK_ERR_IMG_READ: u32 = 33554439;
pub const TSK_ERR_IMG_READ_OFF: u32 = 33554440;
pub const TSK_ERR_IMG_ARG: u32 = 33554441;
pub const TSK_ERR_IMG_MAGIC: u32 = 33554442;
pub const TSK_ERR_IMG_WRITE: u32 = 33554443;
pub const TSK_ERR_IMG_CONVERT: u32 = 33554444;
pub const TSK_ERR_IMG_PASSWD: u32 = 33554445;
pub const TSK_ERR_IMG_MAX: u32 = 14;
pub const TSK_ERR_VS_UNKTYPE: u32 = 67108864;
pub const TSK_ERR_VS_UNSUPTYPE: u32 = 67108865;
pub const TSK_ERR_VS_READ: u32 = 67108866;
pub const TSK_ERR_VS_MAGIC: u32 = 67108867;
pub const TSK_ERR_VS_WALK_RNG: u32 = 67108868;
pub const TSK_ERR_VS_BUF: u32 = 67108869;
pub const TSK_ERR_VS_BLK_NUM: u32 = 67108870;
pub const TSK_ERR_VS_ARG: u32 = 67108871;
pub const TSK_ERR_VS_ENCRYPTED: u32 = 67108872;
pub const TSK_ERR_VS_MULTTYPE: u32 = 67108873;
pub const TSK_ERR_VS_MAX: u32 = 10;
pub const TSK_ERR_POOL_UNKTYPE: u32 = 1073741824;
pub const TSK_ERR_POOL_UNSUPTYPE: u32 = 33554433;
pub const TSK_ERR_POOL_ARG: u32 = 1073741826;
pub const TSK_ERR_POOL_GENPOOL: u32 = 1073741827;
pub const TSK_ERR_POOL_MAX: u32 = 4;
pub const TSK_ERR_FS_UNKTYPE: u32 = 134217728;
pub const TSK_ERR_FS_UNSUPTYPE: u32 = 134217729;
pub const TSK_ERR_FS_UNSUPFUNC: u32 = 134217730;
pub const TSK_ERR_FS_WALK_RNG: u32 = 134217731;
pub const TSK_ERR_FS_READ: u32 = 134217732;
pub const TSK_ERR_FS_READ_OFF: u32 = 134217733;
pub const TSK_ERR_FS_ARG: u32 = 134217734;
pub const TSK_ERR_FS_BLK_NUM: u32 = 134217735;
pub const TSK_ERR_FS_INODE_NUM: u32 = 134217736;
pub const TSK_ERR_FS_INODE_COR: u32 = 134217737;
pub const TSK_ERR_FS_MAGIC: u32 = 134217738;
pub const TSK_ERR_FS_FWALK: u32 = 134217739;
pub const TSK_ERR_FS_WRITE: u32 = 134217740;
pub const TSK_ERR_FS_UNICODE: u32 = 134217741;
pub const TSK_ERR_FS_RECOVER: u32 = 134217742;
pub const TSK_ERR_FS_GENFS: u32 = 134217743;
pub const TSK_ERR_FS_CORRUPT: u32 = 134217744;
pub const TSK_ERR_FS_ATTR_NOTFOUND: u32 = 134217745;
pub const TSK_ERR_FS_ENCRYPTED: u32 = 134217746;
pub const TSK_ERR_FS_POSSIBLY_ENCRYPTED: u32 = 134217747;
pub const TSK_ERR_FS_MULTTYPE: u32 = 134217748;
pub const TSK_ERR_FS_BITLOCKER_ERROR: u32 = 134217749;
pub const TSK_ERR_FS_LARGE_DIR_ERROR: u32 = 134217750;
pub const TSK_ERR_FS_MAX: u32 = 23;
pub const TSK_ERR_HDB_UNKTYPE: u32 = 268435456;
pub const TSK_ERR_HDB_UNSUPTYPE: u32 = 268435457;
pub const TSK_ERR_HDB_READDB: u32 = 268435458;
pub const TSK_ERR_HDB_READIDX: u32 = 268435459;
pub const TSK_ERR_HDB_ARG: u32 = 268435460;
pub const TSK_ERR_HDB_WRITE: u32 = 268435461;
pub const TSK_ERR_HDB_CREATE: u32 = 268435462;
pub const TSK_ERR_HDB_DELETE: u32 = 268435463;
pub const TSK_ERR_HDB_MISSING: u32 = 268435464;
pub const TSK_ERR_HDB_PROC: u32 = 268435465;
pub const TSK_ERR_HDB_OPEN: u32 = 268435466;
pub const TSK_ERR_HDB_CORRUPT: u32 = 268435467;
pub const TSK_ERR_HDB_UNSUPFUNC: u32 = 268435467;
pub const TSK_ERR_HDB_MAX: u32 = 13;
pub const TSK_ERR_AUTO_DB: u32 = 536870912;
pub const TSK_ERR_AUTO_CORRUPT: u32 = 536870913;
pub const TSK_ERR_AUTO_UNICODE: u32 = 536870914;
pub const TSK_ERR_AUTO_NOTOPEN: u32 = 536870915;
pub const TSK_ERR_AUTO_MAX: u32 = 4;
pub const TSK_MD5_DIGEST_LENGTH: u32 = 16;
pub const TSK_SHA_DIGEST_LENGTH: u32 = 32;
pub const TSK_IMG_INFO_CACHE_NUM: u32 = 32;
pub const TSK_IMG_INFO_CACHE_LEN: u32 = 65536;
pub const TSK_IMG_INFO_TAG: u32 = 958415409;
pub const TSK_VS_INFO_TAG: u32 = 1378883138;
pub const TSK_VS_PART_INFO_TAG: u32 = 1074926163;
pub const TSK_FS_BLOCK_TAG: u32 = 461127498;
pub const TSK_FS_ATTR_ID_DEFAULT: u32 = 0;
pub const TSK_FS_META_NAME_LIST_NSIZE: u32 = 512;
pub const TSK_FS_META_TYPE_STR_MAX: u32 = 12;
pub const TSK_FS_META_TAG: u32 = 324159029;
pub const TSK_FS_ORPHAN_STR: &[u8; 14] = b"-ORPHAN_FILE-\0";
pub const TSK_FS_NAME_TYPE_STR_MAX: u32 = 12;
pub const TSK_FS_NAME_TAG: u32 = 588544105;
pub const TSK_FS_DIR_TAG: u32 = 1465061958;
pub const TSK_FS_FILE_TAG: u32 = 287384082;
pub const TSK_FS_INFO_TAG: u32 = 269488144;
pub const TSK_FS_INFO_FS_ID_LEN: u32 = 32;
pub const TSK_HDB_HTYPE_MD5_STR: &[u8; 4] = b"md5\0";
pub const TSK_HDB_HTYPE_SHA1_STR: &[u8; 5] = b"sha1\0";
pub const TSK_HDB_HTYPE_SHA2_256_STR: &[u8; 9] = b"sha2_256\0";
pub const TSK_HDB_HTYPE_SHA2_256_LEN: u32 = 64;
pub const TSK_HDB_HTYPE_SHA1_LEN: u32 = 40;
pub const TSK_HDB_HTYPE_MD5_LEN: u32 = 32;
pub const TSK_HDB_HTYPE_CRC32_LEN: u32 = 8;
pub const TSK_HDB_MAX_BINHASH_LEN: u32 = 32;
pub const TSK_HDB_DBTYPE_NSRL_STR: &[u8; 5] = b"nsrl\0";
pub const TSK_HDB_DBTYPE_NSRL_MD5_STR: &[u8; 9] = b"nsrl-md5\0";
pub const TSK_HDB_DBTYPE_NSRL_SHA1_STR: &[u8; 10] = b"nsrl-sha1\0";
pub const TSK_HDB_DBTYPE_MD5SUM_STR: &[u8; 7] = b"md5sum\0";
pub const TSK_HDB_DBTYPE_HK_STR: &[u8; 3] = b"hk\0";
pub const TSK_HDB_DBTYPE_ENCASE_STR: &[u8; 7] = b"encase\0";
pub const TSK_HDB_DBTYPE_SUPPORT_STR: &[u8; 40] = b"nsrl-md5, nsrl-sha1, md5sum, encase, hk\0";
pub const TSK_HDB_NAME_MAXLEN: u32 = 512;
pub const TSK_POOL_INFO_TAG: u32 = 1347374156;
pub const TSK_POOL_VOL_INFO_TAG: u32 = 1347833676;
pub type va_list = *mut ::std::os::raw::c_char;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type __time64_t = ::std::os::raw::c_longlong;
pub type time_t = __time64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
pub type FILE = _iobuf;
pub type DWORD = ::std::os::raw::c_ulong;
pub type WORD = ::std::os::raw::c_ushort;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = wchar_t;
pub type HANDLE = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
pub type LIST_ENTRY = _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION_DEBUG {
    pub Type: WORD,
    pub CreatorBackTraceIndex: WORD,
    pub CriticalSection: *mut _RTL_CRITICAL_SECTION,
    pub ProcessLocksList: LIST_ENTRY,
    pub EntryCount: DWORD,
    pub ContentionCount: DWORD,
    pub Flags: DWORD,
    pub CreatorBackTraceIndexHigh: WORD,
    pub Identifier: WORD,
}
pub type PRTL_CRITICAL_SECTION_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    pub DebugInfo: PRTL_CRITICAL_SECTION_DEBUG,
    pub LockCount: LONG,
    pub RecursionCount: LONG,
    pub OwningThread: HANDLE,
    pub LockSemaphore: HANDLE,
    pub SpinCount: ULONG_PTR,
}
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
pub type CRITICAL_SECTION = RTL_CRITICAL_SECTION;
pub type TSK_TCHAR = WCHAR;
pub type TSK_ERROR_LISTENER_CB = ::std::option::Option<
    unsafe extern "C" fn(errnum: ::std::os::raw::c_uint, errmsg: *const ::std::os::raw::c_char),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_ERROR_INFO {
    pub t_errno: u32,
    pub errstr: [::std::os::raw::c_char; 1025usize],
    pub errstr2: [::std::os::raw::c_char; 1025usize],
    pub errstr_print: [::std::os::raw::c_char; 1025usize],
}
unsafe extern "C" {
    pub fn tsk_error_get_info() -> *mut TSK_ERROR_INFO;
}
unsafe extern "C" {
    pub fn tsk_error_get_errno() -> u32;
}
unsafe extern "C" {
    pub fn tsk_error_set_errno(t_errno: u32);
}
unsafe extern "C" {
    pub fn tsk_error_get_errstr() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tsk_error_set_errstr(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn tsk_error_vset_errstr(format: *const ::std::os::raw::c_char, args: va_list);
}
unsafe extern "C" {
    pub fn tsk_error_get_errstr2() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tsk_error_set_errstr2(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn tsk_error_vset_errstr2(format: *const ::std::os::raw::c_char, args: va_list);
}
unsafe extern "C" {
    pub fn tsk_error_errstr2_concat(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn tsk_error_set_error_listener(listener: TSK_ERROR_LISTENER_CB);
}
unsafe extern "C" {
    #[doc = " Return a human-readable form of tsk_error_get_errno"]
    pub fn tsk_error_get() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tsk_error_print(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn tsk_error_reset();
}
unsafe extern "C" {
    pub fn tsk_error_win32_get_per_thread_(
        struct_size: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tsk_lock_t {
    pub critical_section: CRITICAL_SECTION,
}
#[doc = "< Ok -- success"]
pub const TSK_RETVAL_ENUM_TSK_OK: TSK_RETVAL_ENUM = 0;
#[doc = "< System error -- should abort"]
pub const TSK_RETVAL_ENUM_TSK_ERR: TSK_RETVAL_ENUM = 1;
#[doc = "< Data is corrupt, can still process another set of data"]
pub const TSK_RETVAL_ENUM_TSK_COR: TSK_RETVAL_ENUM = 2;
#[doc = "< Stop further processing, not an error though."]
pub const TSK_RETVAL_ENUM_TSK_STOP: TSK_RETVAL_ENUM = 3;
#[doc = " Return values for some TSK functions that need to differentiate between errors and corrupt data."]
pub type TSK_RETVAL_ENUM = ::std::os::raw::c_int;
#[doc = " Linked list structure that holds a 'key' and optional 'length'.\n Note that the data is stored in reverse sort order so that inserts\n are faster.  Also note that the length is a negative number. A key of\n '6' and a len of '2' means that the run contains 6 and 5."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_LIST {
    #[doc = "< Pointer to next entry in list"]
    pub next: *mut TSK_LIST,
    #[doc = "< Largest value in this run"]
    pub key: u64,
    #[doc = "< Length of run (negative number, stored as positive)"]
    pub len: u64,
}
unsafe extern "C" {
    pub fn tsk_list_find(list: *mut TSK_LIST, key: u64) -> u8;
}
unsafe extern "C" {
    pub fn tsk_list_add(list: *mut *mut TSK_LIST, key: u64) -> u8;
}
unsafe extern "C" {
    pub fn tsk_list_free(list: *mut TSK_LIST);
}
#[doc = " Basic stack structure to push and pop (used for finding loops in recursion)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_STACK {
    #[doc = "< Array that contains the values in the stack"]
    pub vals: *mut u64,
    #[doc = "< Index to the top stack entry"]
    pub top: usize,
    #[doc = "< Number of entries in the stack"]
    pub len: usize,
}
unsafe extern "C" {
    pub fn tsk_stack_push(stack: *mut TSK_STACK, key: u64) -> u8;
}
unsafe extern "C" {
    pub fn tsk_stack_pop(stack: *mut TSK_STACK);
}
unsafe extern "C" {
    pub fn tsk_stack_find(stack: *mut TSK_STACK, key: u64) -> u8;
}
unsafe extern "C" {
    pub fn tsk_stack_free(stack: *mut TSK_STACK);
}
unsafe extern "C" {
    pub fn tsk_stack_create() -> *mut TSK_STACK;
}
unsafe extern "C" {
    pub fn tsk_fprintf(fd: *mut FILE, msg: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn tsk_printf(msg: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn tsk_print_sanitized(
        fd: *mut FILE,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type TSK_INUM_T = u64;
pub type TSK_UID_T = u32;
pub type TSK_GID_T = u32;
pub type TSK_DADDR_T = u64;
pub type TSK_OFF_T = i64;
pub type TSK_PNUM_T = u32;
unsafe extern "C" {
    pub fn tsk_version_print(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn tsk_version_get_str() -> *const ::std::os::raw::c_char;
}
#[doc = "< Walk function should continue to next object"]
pub const TSK_WALK_RET_ENUM_TSK_WALK_CONT: TSK_WALK_RET_ENUM = 0;
#[doc = "< Walk function should stop processing units and return OK"]
pub const TSK_WALK_RET_ENUM_TSK_WALK_STOP: TSK_WALK_RET_ENUM = 1;
#[doc = "< Walk function should stop processing units and return error"]
pub const TSK_WALK_RET_ENUM_TSK_WALK_ERROR: TSK_WALK_RET_ENUM = 2;
#[doc = " Values that callback functions can return to calling walk function."]
pub type TSK_WALK_RET_ENUM = ::std::os::raw::c_int;
#[doc = "< Endianness is unknown"]
pub const TSK_ENDIAN_ENUM_TSK_UNKNOWN_ENDIAN: TSK_ENDIAN_ENUM = 0;
#[doc = "< Data is in little endian"]
pub const TSK_ENDIAN_ENUM_TSK_LIT_ENDIAN: TSK_ENDIAN_ENUM = 1;
#[doc = "< Data is in big endian"]
pub const TSK_ENDIAN_ENUM_TSK_BIG_ENDIAN: TSK_ENDIAN_ENUM = 2;
#[doc = " Flag that identifies the endian ordering of the data being read."]
pub type TSK_ENDIAN_ENUM = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn tsk_parse_offset(arg1: *const TSK_TCHAR) -> TSK_OFF_T;
}
unsafe extern "C" {
    pub fn tsk_parse_pnum(
        a_pnum_str: *const TSK_TCHAR,
        a_pnum: *mut TSK_PNUM_T,
    ) -> ::std::os::raw::c_int;
}
pub type UINT4 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_MD5_CTX {
    pub state: [UINT4; 4usize],
    pub count: [UINT4; 2usize],
    pub buffer: [::std::os::raw::c_uchar; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_SHA_CTX {
    pub digest: [UINT4; 5usize],
    pub countLo: UINT4,
    pub countHi: UINT4,
    pub data: [UINT4; 16usize],
    pub Endianness: ::std::os::raw::c_int,
}
pub const TSK_BASE_HASH_ENUM_TSK_BASE_HASH_INVALID_ID: TSK_BASE_HASH_ENUM = 0;
pub const TSK_BASE_HASH_ENUM_TSK_BASE_HASH_MD5: TSK_BASE_HASH_ENUM = 1;
pub const TSK_BASE_HASH_ENUM_TSK_BASE_HASH_SHA1: TSK_BASE_HASH_ENUM = 2;
pub type TSK_BASE_HASH_ENUM = ::std::os::raw::c_int;
#[doc = "< Use autodetection methods"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_DETECT: TSK_IMG_TYPE_ENUM = 0;
#[doc = "< Raw disk image (single or split)"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_RAW: TSK_IMG_TYPE_ENUM = 1;
#[doc = "< Raw single (backward compatibility) depreciated"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_RAW_SING: TSK_IMG_TYPE_ENUM = 1;
#[doc = "< Raw single (backward compatibility) depreciated"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_RAW_SPLIT: TSK_IMG_TYPE_ENUM = 1;
#[doc = "< AFF AFF Format"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_AFF_AFF: TSK_IMG_TYPE_ENUM = 4;
#[doc = "< AFD AFF Format"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_AFF_AFD: TSK_IMG_TYPE_ENUM = 8;
#[doc = "< AFM AFF Format"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_AFF_AFM: TSK_IMG_TYPE_ENUM = 16;
#[doc = "< Any format supported by AFFLIB (including beta ones)"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_AFF_ANY: TSK_IMG_TYPE_ENUM = 32;
#[doc = "< EWF version"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_EWF_EWF: TSK_IMG_TYPE_ENUM = 64;
#[doc = "< VMDK version"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_VMDK_VMDK: TSK_IMG_TYPE_ENUM = 128;
#[doc = "< VHD version"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_VHD_VHD: TSK_IMG_TYPE_ENUM = 256;
#[doc = "< AFF4 version"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_AFF4_AFF4: TSK_IMG_TYPE_ENUM = 512;
#[doc = "< QCOW version"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_QCOW_QCOW: TSK_IMG_TYPE_ENUM = 1024;
#[doc = "< external defined format which at least implements TSK_IMG_INFO, used by pytsk"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_EXTERNAL: TSK_IMG_TYPE_ENUM = 4096;
#[doc = "< Pool"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_POOL: TSK_IMG_TYPE_ENUM = 16384;
#[doc = "< Logical directory"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_LOGICAL: TSK_IMG_TYPE_ENUM = 32768;
#[doc = "< Unsupported disk image type"]
pub const TSK_IMG_TYPE_ENUM_TSK_IMG_TYPE_UNSUPP: TSK_IMG_TYPE_ENUM = 65535;
#[doc = " Flag values for the disk image format type.  Each type has a\n bit associated with it.  There are TSK_IMG_TYPE_ISXXX macros\n to determine the broad group of the type (raw vs aff etc.)"]
pub type TSK_IMG_TYPE_ENUM = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_IMG_OPTIONS {
    pub dummy: ::std::os::raw::c_int,
}
#[doc = " Created when a disk image has been opened and stores general information and handles."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_IMG_INFO {
    #[doc = "< Set to TSK_IMG_INFO_TAG when struct is alloc"]
    pub tag: u32,
    #[doc = "< Type of disk image format"]
    pub itype: TSK_IMG_TYPE_ENUM,
    #[doc = "< Total size of image in bytes"]
    pub size: TSK_OFF_T,
    #[doc = "< Number of image files"]
    pub num_img: ::std::os::raw::c_int,
    #[doc = "< sector size of device in bytes (typically 512)"]
    pub sector_size: ::std::os::raw::c_uint,
    #[doc = "< page size of NAND page in bytes (defaults to 2048)"]
    pub page_size: ::std::os::raw::c_uint,
    #[doc = "< spare or OOB size of NAND in bytes (defaults to 64)"]
    pub spare_size: ::std::os::raw::c_uint,
    #[doc = "< Image names"]
    pub images: *mut *mut TSK_TCHAR,
}
unsafe extern "C" {
    pub fn tsk_img_open_sing(
        a_image: *const TSK_TCHAR,
        type_: TSK_IMG_TYPE_ENUM,
        a_ssize: ::std::os::raw::c_uint,
    ) -> *mut TSK_IMG_INFO;
}
unsafe extern "C" {
    pub fn tsk_img_open(
        num_img: ::std::os::raw::c_int,
        images: *const *const TSK_TCHAR,
        arg1: TSK_IMG_TYPE_ENUM,
        a_ssize: ::std::os::raw::c_uint,
    ) -> *mut TSK_IMG_INFO;
}
unsafe extern "C" {
    pub fn tsk_img_open_utf8_sing(
        a_image: *const ::std::os::raw::c_char,
        type_: TSK_IMG_TYPE_ENUM,
        a_ssize: ::std::os::raw::c_uint,
    ) -> *mut TSK_IMG_INFO;
}
unsafe extern "C" {
    pub fn tsk_img_open_utf8(
        num_img: ::std::os::raw::c_int,
        images: *const *const ::std::os::raw::c_char,
        type_: TSK_IMG_TYPE_ENUM,
        a_ssize: ::std::os::raw::c_uint,
    ) -> *mut TSK_IMG_INFO;
}
unsafe extern "C" {
    pub fn tsk_img_open_sing_opt(
        a_image: *const TSK_TCHAR,
        type_: TSK_IMG_TYPE_ENUM,
        a_ssize: ::std::os::raw::c_uint,
        opts: *const TSK_IMG_OPTIONS,
    ) -> *mut TSK_IMG_INFO;
}
unsafe extern "C" {
    pub fn tsk_img_open_opt(
        num_img: ::std::os::raw::c_int,
        images: *const *const TSK_TCHAR,
        arg1: TSK_IMG_TYPE_ENUM,
        a_ssize: ::std::os::raw::c_uint,
        opts: *const TSK_IMG_OPTIONS,
    ) -> *mut TSK_IMG_INFO;
}
unsafe extern "C" {
    pub fn tsk_img_open_utf8_sing_opt(
        a_image: *const ::std::os::raw::c_char,
        type_: TSK_IMG_TYPE_ENUM,
        a_ssize: ::std::os::raw::c_uint,
        opts: *const TSK_IMG_OPTIONS,
    ) -> *mut TSK_IMG_INFO;
}
unsafe extern "C" {
    pub fn tsk_img_open_utf8_opt(
        num_img: ::std::os::raw::c_int,
        images: *const *const ::std::os::raw::c_char,
        type_: TSK_IMG_TYPE_ENUM,
        a_ssize: ::std::os::raw::c_uint,
        opts: *const TSK_IMG_OPTIONS,
    ) -> *mut TSK_IMG_INFO;
}
unsafe extern "C" {
    pub fn tsk_img_open_external(
        ext_img_info: *mut ::std::os::raw::c_void,
        size: TSK_OFF_T,
        sector_size: ::std::os::raw::c_uint,
        read: ::std::option::Option<
            unsafe extern "C" fn(
                img: *mut TSK_IMG_INFO,
                off: TSK_OFF_T,
                buf: *mut ::std::os::raw::c_char,
                len: usize,
            ) -> isize,
        >,
        close: ::std::option::Option<unsafe extern "C" fn(arg1: *mut TSK_IMG_INFO)>,
        imgstat: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut TSK_IMG_INFO, arg2: *mut FILE),
        >,
    ) -> *mut TSK_IMG_INFO;
}
unsafe extern "C" {
    pub fn tsk_img_close(arg1: *mut TSK_IMG_INFO);
}
unsafe extern "C" {
    pub fn tsk_img_read(
        img: *mut TSK_IMG_INFO,
        off: TSK_OFF_T,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn tsk_img_type_toid_utf8(arg1: *const ::std::os::raw::c_char) -> TSK_IMG_TYPE_ENUM;
}
unsafe extern "C" {
    pub fn tsk_img_type_toid(arg1: *const TSK_TCHAR) -> TSK_IMG_TYPE_ENUM;
}
unsafe extern "C" {
    pub fn tsk_img_type_toname(arg1: TSK_IMG_TYPE_ENUM) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tsk_img_type_todesc(arg1: TSK_IMG_TYPE_ENUM) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tsk_img_type_supported() -> TSK_IMG_TYPE_ENUM;
}
unsafe extern "C" {
    pub fn tsk_img_type_print(arg1: *mut FILE);
}
#[doc = " Definition for callback function that vs_part_walk() calls for\n each partition that it walks.\n\n @param a_vs Pointer to volume system being analyzed\n @param a_vs_part Pointer to current partition in the walk\n @param a_ptr Pointer that was passed to vs_part_walk by caller\n @return Status on whether the vs_part_walk() function should\n continue, stop, or error."]
pub type TSK_VS_PART_WALK_CB = ::std::option::Option<
    unsafe extern "C" fn(
        a_vs: *mut TSK_VS_INFO,
        a_vs_part: *const TSK_VS_PART_INFO,
        a_ptr: *mut ::std::os::raw::c_void,
    ) -> TSK_WALK_RET_ENUM,
>;
#[doc = "< Use autodetection methods"]
pub const TSK_VS_TYPE_ENUM_TSK_VS_TYPE_DETECT: TSK_VS_TYPE_ENUM = 0;
#[doc = "< DOS Partition table"]
pub const TSK_VS_TYPE_ENUM_TSK_VS_TYPE_DOS: TSK_VS_TYPE_ENUM = 1;
#[doc = "< BSD Partition table"]
pub const TSK_VS_TYPE_ENUM_TSK_VS_TYPE_BSD: TSK_VS_TYPE_ENUM = 2;
#[doc = "< Sun VTOC"]
pub const TSK_VS_TYPE_ENUM_TSK_VS_TYPE_SUN: TSK_VS_TYPE_ENUM = 4;
#[doc = "< Mac partition table"]
pub const TSK_VS_TYPE_ENUM_TSK_VS_TYPE_MAC: TSK_VS_TYPE_ENUM = 8;
#[doc = "< GPT partition table"]
pub const TSK_VS_TYPE_ENUM_TSK_VS_TYPE_GPT: TSK_VS_TYPE_ENUM = 16;
#[doc = "< APFS"]
pub const TSK_VS_TYPE_ENUM_TSK_VS_TYPE_APFS: TSK_VS_TYPE_ENUM = 32;
#[doc = "< LVM"]
pub const TSK_VS_TYPE_ENUM_TSK_VS_TYPE_LVM: TSK_VS_TYPE_ENUM = 48;
#[doc = "< fake partition table type for loaddb (for images that do not have a volume system)"]
pub const TSK_VS_TYPE_ENUM_TSK_VS_TYPE_DBFILLER: TSK_VS_TYPE_ENUM = 240;
#[doc = "< Unsupported"]
pub const TSK_VS_TYPE_ENUM_TSK_VS_TYPE_UNSUPP: TSK_VS_TYPE_ENUM = 65535;
#[doc = " Flags for the partition type."]
pub type TSK_VS_TYPE_ENUM = ::std::os::raw::c_int;
#[doc = " Data structure used to store state and basic information\n for open volume systems."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_VS_INFO {
    #[doc = "< \\internal Will be set to TSK_VS_INFO_TAG if structure is still allocated, 0 if not"]
    pub tag: ::std::os::raw::c_int,
    #[doc = "< Pointer to disk image that VS is in"]
    pub img_info: *mut TSK_IMG_INFO,
    #[doc = "< Type of volume system / media management"]
    pub vstype: TSK_VS_TYPE_ENUM,
    #[doc = "< 1 if the partition table found was a backup"]
    pub is_backup: ::std::os::raw::c_int,
    #[doc = "< Byte offset where VS starts in disk image"]
    pub offset: TSK_DADDR_T,
    #[doc = "< Size of blocks in bytes"]
    pub block_size: ::std::os::raw::c_uint,
    #[doc = "< Endian ordering of data"]
    pub endian: TSK_ENDIAN_ENUM,
    #[doc = "< Linked list of partitions"]
    pub part_list: *mut TSK_VS_PART_INFO,
    #[doc = "< number of partitions"]
    pub part_count: TSK_PNUM_T,
    #[doc = "< \\internal Progs should call tsk_vs_close()."]
    pub close: ::std::option::Option<unsafe extern "C" fn(arg1: *mut TSK_VS_INFO)>,
}
#[doc = "< Sectors are allocated to a volume in the volume system"]
pub const TSK_VS_PART_FLAG_ENUM_TSK_VS_PART_FLAG_ALLOC: TSK_VS_PART_FLAG_ENUM = 1;
#[doc = "< Sectors are not allocated to a volume"]
pub const TSK_VS_PART_FLAG_ENUM_TSK_VS_PART_FLAG_UNALLOC: TSK_VS_PART_FLAG_ENUM = 2;
#[doc = "< Sectors contain volume system metadata and could also be ALLOC or UNALLOC"]
pub const TSK_VS_PART_FLAG_ENUM_TSK_VS_PART_FLAG_META: TSK_VS_PART_FLAG_ENUM = 4;
#[doc = "< Show all sectors in the walk."]
pub const TSK_VS_PART_FLAG_ENUM_TSK_VS_PART_FLAG_ALL: TSK_VS_PART_FLAG_ENUM = 7;
#[doc = " Flag values that describe the partitions in the VS.  Refer\n to \\ref vs_open2 for more details."]
pub type TSK_VS_PART_FLAG_ENUM = ::std::os::raw::c_int;
#[doc = " Linked list entry that describes a volume in a generic way."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_VS_PART_INFO {
    pub tag: ::std::os::raw::c_int,
    #[doc = "< Pointer to previous partition (or NULL)"]
    pub prev: *mut TSK_VS_PART_INFO,
    #[doc = "< Pointer to next partition (or NULL)"]
    pub next: *mut TSK_VS_PART_INFO,
    #[doc = "< Pointer to parent volume system handle"]
    pub vs: *mut TSK_VS_INFO,
    #[doc = "< Sector offset of start of partition"]
    pub start: TSK_DADDR_T,
    #[doc = "< Number of sectors in partition"]
    pub len: TSK_DADDR_T,
    #[doc = "< UTF-8 description of partition (volume system type-specific)"]
    pub desc: *mut ::std::os::raw::c_char,
    #[doc = "< Table address that describes this partition"]
    pub table_num: i8,
    #[doc = "< Entry in the table that describes this partition"]
    pub slot_num: i16,
    #[doc = "< Address of this partition"]
    pub addr: TSK_PNUM_T,
    #[doc = "< Flags for partition"]
    pub flags: TSK_VS_PART_FLAG_ENUM,
}
unsafe extern "C" {
    pub fn tsk_vs_type_toid(arg1: *const TSK_TCHAR) -> TSK_VS_TYPE_ENUM;
}
unsafe extern "C" {
    pub fn tsk_vs_type_toid_utf8(arg1: *const ::std::os::raw::c_char) -> TSK_VS_TYPE_ENUM;
}
unsafe extern "C" {
    pub fn tsk_vs_type_toname(arg1: TSK_VS_TYPE_ENUM) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tsk_vs_type_todesc(arg1: TSK_VS_TYPE_ENUM) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tsk_vs_type_supported() -> TSK_VS_TYPE_ENUM;
}
unsafe extern "C" {
    pub fn tsk_vs_type_print(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn tsk_vs_open(
        arg1: *mut TSK_IMG_INFO,
        arg2: TSK_DADDR_T,
        arg3: TSK_VS_TYPE_ENUM,
    ) -> *mut TSK_VS_INFO;
}
unsafe extern "C" {
    pub fn tsk_vs_close(arg1: *mut TSK_VS_INFO);
}
unsafe extern "C" {
    pub fn tsk_vs_read_block(
        a_vs: *mut TSK_VS_INFO,
        a_addr: TSK_DADDR_T,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn tsk_vs_part_get(arg1: *const TSK_VS_INFO, idx: TSK_PNUM_T) -> *const TSK_VS_PART_INFO;
}
unsafe extern "C" {
    pub fn tsk_vs_part_walk(
        vs: *mut TSK_VS_INFO,
        start: TSK_PNUM_T,
        last: TSK_PNUM_T,
        flags: TSK_VS_PART_FLAG_ENUM,
        action: TSK_VS_PART_WALK_CB,
        ptr: *mut ::std::os::raw::c_void,
    ) -> u8;
}
unsafe extern "C" {
    pub fn tsk_vs_part_read(
        a_vs_part: *const TSK_VS_PART_INFO,
        a_off: TSK_OFF_T,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn tsk_vs_part_read_block(
        a_vs_part: *const TSK_VS_PART_INFO,
        a_addr: TSK_DADDR_T,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> isize;
}
pub type TSK_POOL_INFO = _TSK_POOL_INFO;
#[doc = "< Used to show that TSK_FS_BLOCK structure has no data in it"]
pub const TSK_FS_BLOCK_FLAG_ENUM_TSK_FS_BLOCK_FLAG_UNUSED: TSK_FS_BLOCK_FLAG_ENUM = 0;
#[doc = "< Block is allocated (and not TSK_FS_BLOCK_FLAG_UNALLOC)"]
pub const TSK_FS_BLOCK_FLAG_ENUM_TSK_FS_BLOCK_FLAG_ALLOC: TSK_FS_BLOCK_FLAG_ENUM = 1;
#[doc = "< Block is unallocated (and not TSK_FS_BLOCK_FLAG_ALLOC)"]
pub const TSK_FS_BLOCK_FLAG_ENUM_TSK_FS_BLOCK_FLAG_UNALLOC: TSK_FS_BLOCK_FLAG_ENUM = 2;
#[doc = "< Block (could) contain file content (and not TSK_FS_BLOCK_FLAG_META)"]
pub const TSK_FS_BLOCK_FLAG_ENUM_TSK_FS_BLOCK_FLAG_CONT: TSK_FS_BLOCK_FLAG_ENUM = 4;
#[doc = "< Block (could) contain file system metadata (and not TSK_FS_BLOCK_FLAG_CONT)"]
pub const TSK_FS_BLOCK_FLAG_ENUM_TSK_FS_BLOCK_FLAG_META: TSK_FS_BLOCK_FLAG_ENUM = 8;
#[doc = "< Block has been marked as bad by the file system"]
pub const TSK_FS_BLOCK_FLAG_ENUM_TSK_FS_BLOCK_FLAG_BAD: TSK_FS_BLOCK_FLAG_ENUM = 16;
#[doc = "< The data has been read raw from the disk (and not COMP or SPARSE)"]
pub const TSK_FS_BLOCK_FLAG_ENUM_TSK_FS_BLOCK_FLAG_RAW: TSK_FS_BLOCK_FLAG_ENUM = 32;
#[doc = "< The data passed in the file_walk callback was stored as sparse (all zeros) (and not RAW or COMP)"]
pub const TSK_FS_BLOCK_FLAG_ENUM_TSK_FS_BLOCK_FLAG_SPARSE: TSK_FS_BLOCK_FLAG_ENUM = 64;
#[doc = "< The data passed in the file_walk callback was stored in a compressed form (and not RAW or SPARSE)"]
pub const TSK_FS_BLOCK_FLAG_ENUM_TSK_FS_BLOCK_FLAG_COMP: TSK_FS_BLOCK_FLAG_ENUM = 128;
#[doc = "< The data passed in the file_walk callback is from an NTFS resident file"]
pub const TSK_FS_BLOCK_FLAG_ENUM_TSK_FS_BLOCK_FLAG_RES: TSK_FS_BLOCK_FLAG_ENUM = 256;
pub const TSK_FS_BLOCK_FLAG_ENUM_TSK_FS_BLOCK_FLAG_AONLY: TSK_FS_BLOCK_FLAG_ENUM = 512;
#[doc = " Flags that are used in TSK_FS_BLOCK and in callback of file_walk.\n Note that some of these are dependent. A block can be either TSK_FS_BLOCK_FLAG_ALLOC\n or TSK_FS_BLOCK_FLAG_UNALLOC.  It can be one of TSK_FS_BLOCK_FLAG_RAW, TSK_FS_BLOCK_FLAG_BAD,\n TSK_FS_BLOCK_FLAG_RES, TSK_FS_BLOCK_FLAG_SPARSE, or TSK_FS_BLOCK_FLAG_COMP.  Note that some of\n these are set only by file_walk because they are file-level details, such as compression and sparse."]
pub type TSK_FS_BLOCK_FLAG_ENUM = ::std::os::raw::c_int;
#[doc = "< No Flags"]
pub const TSK_FS_BLOCK_WALK_FLAG_ENUM_TSK_FS_BLOCK_WALK_FLAG_NONE: TSK_FS_BLOCK_WALK_FLAG_ENUM = 0;
#[doc = "< Allocated blocks"]
pub const TSK_FS_BLOCK_WALK_FLAG_ENUM_TSK_FS_BLOCK_WALK_FLAG_ALLOC: TSK_FS_BLOCK_WALK_FLAG_ENUM = 1;
#[doc = "< Unallocated blocks"]
pub const TSK_FS_BLOCK_WALK_FLAG_ENUM_TSK_FS_BLOCK_WALK_FLAG_UNALLOC: TSK_FS_BLOCK_WALK_FLAG_ENUM =
    2;
#[doc = "< Blocks that could store file content"]
pub const TSK_FS_BLOCK_WALK_FLAG_ENUM_TSK_FS_BLOCK_WALK_FLAG_CONT: TSK_FS_BLOCK_WALK_FLAG_ENUM = 4;
#[doc = "< Blocks that could store file system metadata"]
pub const TSK_FS_BLOCK_WALK_FLAG_ENUM_TSK_FS_BLOCK_WALK_FLAG_META: TSK_FS_BLOCK_WALK_FLAG_ENUM = 8;
#[doc = "< Do not include content in callback only address and allocation status"]
pub const TSK_FS_BLOCK_WALK_FLAG_ENUM_TSK_FS_BLOCK_WALK_FLAG_AONLY: TSK_FS_BLOCK_WALK_FLAG_ENUM =
    16;
#[doc = " Flags that are used to specify which blocks to call the tsk_fs_block_walk() callback function with."]
pub type TSK_FS_BLOCK_WALK_FLAG_ENUM = ::std::os::raw::c_int;
#[doc = " Generic data structure to hold block data with metadata"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_BLOCK {
    #[doc = "< \\internal Will be set to TSK_FS_BLOCK_TAG if structure is valid / allocated"]
    pub tag: ::std::os::raw::c_int,
    #[doc = "< Pointer to file system that block is from"]
    pub fs_info: *mut TSK_FS_INFO,
    #[doc = "< Buffer with block data (of size TSK_FS_INFO::block_size)"]
    pub buf: *mut ::std::os::raw::c_char,
    #[doc = "< Address of block"]
    pub addr: TSK_DADDR_T,
    pub flags: TSK_FS_BLOCK_FLAG_ENUM,
}
#[doc = " Function definition used for callback to tsk_fs_block_walk().\n\n @param a_block Pointer to block structure that holds block content and flags\n @param a_ptr Pointer that was supplied by the caller who called tsk_fs_block_walk\n @returns Value to identify if walk should continue, stop, or stop because of error"]
pub type TSK_FS_BLOCK_WALK_CB = ::std::option::Option<
    unsafe extern "C" fn(
        a_block: *const TSK_FS_BLOCK,
        a_ptr: *mut ::std::os::raw::c_void,
    ) -> TSK_WALK_RET_ENUM,
>;
unsafe extern "C" {
    pub fn tsk_fs_block_free(a_fs_block: *mut TSK_FS_BLOCK);
}
unsafe extern "C" {
    pub fn tsk_fs_block_get(
        fs: *mut TSK_FS_INFO,
        fs_block: *mut TSK_FS_BLOCK,
        addr: TSK_DADDR_T,
    ) -> *mut TSK_FS_BLOCK;
}
unsafe extern "C" {
    pub fn tsk_fs_block_get_flag(
        a_fs: *mut TSK_FS_INFO,
        a_fs_block: *mut TSK_FS_BLOCK,
        a_addr: TSK_DADDR_T,
        a_flags: TSK_FS_BLOCK_FLAG_ENUM,
    ) -> *mut TSK_FS_BLOCK;
}
unsafe extern "C" {
    pub fn tsk_fs_block_walk(
        a_fs: *mut TSK_FS_INFO,
        a_start_blk: TSK_DADDR_T,
        a_end_blk: TSK_DADDR_T,
        a_flags: TSK_FS_BLOCK_WALK_FLAG_ENUM,
        a_action: TSK_FS_BLOCK_WALK_CB,
        a_ptr: *mut ::std::os::raw::c_void,
    ) -> u8;
}
#[doc = "< No Flag"]
pub const TSK_FS_ATTR_RUN_FLAG_ENUM_TSK_FS_ATTR_RUN_FLAG_NONE: TSK_FS_ATTR_RUN_FLAG_ENUM = 0;
#[doc = "< Entry is a filler for a run that has not been seen yet in the processing (or has been lost)"]
pub const TSK_FS_ATTR_RUN_FLAG_ENUM_TSK_FS_ATTR_RUN_FLAG_FILLER: TSK_FS_ATTR_RUN_FLAG_ENUM = 1;
#[doc = "< Entry is a sparse run where all data in the run is zeros"]
pub const TSK_FS_ATTR_RUN_FLAG_ENUM_TSK_FS_ATTR_RUN_FLAG_SPARSE: TSK_FS_ATTR_RUN_FLAG_ENUM = 2;
#[doc = "< Entry is arun where the data is encrypted"]
pub const TSK_FS_ATTR_RUN_FLAG_ENUM_TSK_FS_ATTR_RUN_FLAG_ENCRYPTED: TSK_FS_ATTR_RUN_FLAG_ENUM = 4;
#[doc = " Flags used for a TSK_FS_ATTR_RUN entry."]
pub type TSK_FS_ATTR_RUN_FLAG_ENUM = ::std::os::raw::c_int;
#[doc = " Holds information about a single data run, which has a starting address and length.\n A run describes a consecutive list of blocks that have been allocated to a file.\n A file may have many such runs and they are stringed together in a linked list.\n The entries in the list must be stored in sequential order (based on offset in file)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_ATTR_RUN {
    #[doc = "< Pointer to the next run in the attribute (or NULL)"]
    pub next: *mut TSK_FS_ATTR_RUN,
    #[doc = "< Offset (in blocks) of this run in the file"]
    pub offset: TSK_DADDR_T,
    #[doc = "< Starting block address (in file system) of run"]
    pub addr: TSK_DADDR_T,
    #[doc = "< Number of blocks in run (0 when entry is not in use)"]
    pub len: TSK_DADDR_T,
    #[doc = "< Starting block number used for XTS encryption IV"]
    pub crypto_id: TSK_DADDR_T,
    #[doc = "< Flags for run"]
    pub flags: TSK_FS_ATTR_RUN_FLAG_ENUM,
}
unsafe extern "C" {
    pub fn tsk_fs_attr_run_free(arg1: *mut TSK_FS_ATTR_RUN);
}
#[doc = "< No Flag"]
pub const TSK_FS_ATTR_FLAG_ENUM_TSK_FS_ATTR_FLAG_NONE: TSK_FS_ATTR_FLAG_ENUM = 0;
#[doc = "< data structure is in use"]
pub const TSK_FS_ATTR_FLAG_ENUM_TSK_FS_ATTR_INUSE: TSK_FS_ATTR_FLAG_ENUM = 1;
#[doc = "< Contains non-resident data (i.e. located in blocks)"]
pub const TSK_FS_ATTR_FLAG_ENUM_TSK_FS_ATTR_NONRES: TSK_FS_ATTR_FLAG_ENUM = 2;
#[doc = "< Contains resident data (i.e. in a small buffer)"]
pub const TSK_FS_ATTR_FLAG_ENUM_TSK_FS_ATTR_RES: TSK_FS_ATTR_FLAG_ENUM = 4;
#[doc = "< Contains encrypted data"]
pub const TSK_FS_ATTR_FLAG_ENUM_TSK_FS_ATTR_ENC: TSK_FS_ATTR_FLAG_ENUM = 16;
#[doc = "< Contains compressed data"]
pub const TSK_FS_ATTR_FLAG_ENUM_TSK_FS_ATTR_COMP: TSK_FS_ATTR_FLAG_ENUM = 32;
#[doc = "< Contains sparse data"]
pub const TSK_FS_ATTR_FLAG_ENUM_TSK_FS_ATTR_SPARSE: TSK_FS_ATTR_FLAG_ENUM = 64;
#[doc = "< Data was determined in file recovery mode"]
pub const TSK_FS_ATTR_FLAG_ENUM_TSK_FS_ATTR_RECOVERY: TSK_FS_ATTR_FLAG_ENUM = 128;
#[doc = " Flags used for the TSK_FS_ATTR structure, which is used to\n store file content metadata."]
pub type TSK_FS_ATTR_FLAG_ENUM = ::std::os::raw::c_int;
#[doc = " File walk callback function definition.  This is called for\n chunks of content in the file being processed.\n @param a_fs_file Pointer to file being processed\n @param a_off Byte offset in file that this data is for\n @param a_addr Address of data being passed (valid only if a_flags have RAW set)\n @param a_buf Pointer to buffer with file content\n @param a_len Size of data in buffer (in bytes)\n @param a_flags Flags about the file content\n @param a_ptr Pointer that was specified by caller to inode_walk\n @returns Value that tells file walk to continue or stop"]
pub type TSK_FS_FILE_WALK_CB = ::std::option::Option<
    unsafe extern "C" fn(
        a_fs_file: *mut TSK_FS_FILE,
        a_off: TSK_OFF_T,
        a_addr: TSK_DADDR_T,
        a_buf: *mut ::std::os::raw::c_char,
        a_len: usize,
        a_flags: TSK_FS_BLOCK_FLAG_ENUM,
        a_ptr: *mut ::std::os::raw::c_void,
    ) -> TSK_WALK_RET_ENUM,
>;
#[doc = "< No Flag"]
pub const TSK_FS_FILE_WALK_FLAG_ENUM_TSK_FS_FILE_WALK_FLAG_NONE: TSK_FS_FILE_WALK_FLAG_ENUM = 0;
#[doc = "< Include the file's slack space in the callback."]
pub const TSK_FS_FILE_WALK_FLAG_ENUM_TSK_FS_FILE_WALK_FLAG_SLACK: TSK_FS_FILE_WALK_FLAG_ENUM = 1;
#[doc = "< Ignore the Id argument given in the API (use only the type)"]
pub const TSK_FS_FILE_WALK_FLAG_ENUM_TSK_FS_FILE_WALK_FLAG_NOID: TSK_FS_FILE_WALK_FLAG_ENUM = 2;
#[doc = "< Provide callback with only addresses and no file content."]
pub const TSK_FS_FILE_WALK_FLAG_ENUM_TSK_FS_FILE_WALK_FLAG_AONLY: TSK_FS_FILE_WALK_FLAG_ENUM = 4;
#[doc = "< Do not include sparse blocks in the callback."]
pub const TSK_FS_FILE_WALK_FLAG_ENUM_TSK_FS_FILE_WALK_FLAG_NOSPARSE: TSK_FS_FILE_WALK_FLAG_ENUM = 8;
#[doc = " Flags used by tsk_fs_file_walk to determine when the callback function should\n be used."]
pub type TSK_FS_FILE_WALK_FLAG_ENUM = ::std::os::raw::c_int;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NOT_FOUND: TSK_FS_ATTR_TYPE_ENUM = 0;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_DEFAULT: TSK_FS_ATTR_TYPE_ENUM = 1;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_SI: TSK_FS_ATTR_TYPE_ENUM = 16;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_ATTRLIST: TSK_FS_ATTR_TYPE_ENUM = 32;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_FNAME: TSK_FS_ATTR_TYPE_ENUM = 48;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_VVER: TSK_FS_ATTR_TYPE_ENUM = 64;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_OBJID: TSK_FS_ATTR_TYPE_ENUM = 64;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_SEC: TSK_FS_ATTR_TYPE_ENUM = 80;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_VNAME: TSK_FS_ATTR_TYPE_ENUM = 96;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_VINFO: TSK_FS_ATTR_TYPE_ENUM = 112;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_DATA: TSK_FS_ATTR_TYPE_ENUM = 128;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_IDXROOT: TSK_FS_ATTR_TYPE_ENUM = 144;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_IDXALLOC: TSK_FS_ATTR_TYPE_ENUM = 160;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_BITMAP: TSK_FS_ATTR_TYPE_ENUM = 176;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_SYMLNK: TSK_FS_ATTR_TYPE_ENUM = 192;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_REPARSE: TSK_FS_ATTR_TYPE_ENUM = 192;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_EAINFO: TSK_FS_ATTR_TYPE_ENUM = 208;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_EA: TSK_FS_ATTR_TYPE_ENUM = 224;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_PROP: TSK_FS_ATTR_TYPE_ENUM = 240;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_NTFS_LOG: TSK_FS_ATTR_TYPE_ENUM = 256;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_UNIX_INDIR: TSK_FS_ATTR_TYPE_ENUM = 4097;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_UNIX_EXTENT: TSK_FS_ATTR_TYPE_ENUM = 4098;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_UNIX_XATTR: TSK_FS_ATTR_TYPE_ENUM = 4099;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_HFS_DEFAULT: TSK_FS_ATTR_TYPE_ENUM = 1;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_HFS_DATA: TSK_FS_ATTR_TYPE_ENUM = 4352;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_HFS_RSRC: TSK_FS_ATTR_TYPE_ENUM = 4353;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_HFS_EXT_ATTR: TSK_FS_ATTR_TYPE_ENUM = 4354;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_HFS_COMP_REC: TSK_FS_ATTR_TYPE_ENUM = 4355;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_APFS_DATA: TSK_FS_ATTR_TYPE_ENUM = 4352;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_APFS_RSRC: TSK_FS_ATTR_TYPE_ENUM = 4353;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_APFS_EXT_ATTR: TSK_FS_ATTR_TYPE_ENUM = 4354;
pub const TSK_FS_ATTR_TYPE_ENUM_TSK_FS_ATTR_TYPE_APFS_COMP_REC: TSK_FS_ATTR_TYPE_ENUM = 4355;
#[doc = " These are based on the NTFS type values.\n Added types for HFS+.\n NOTE: Update bindings/java/src/org/sleuthkit/datamodel/TskData.java\n with any changes."]
pub type TSK_FS_ATTR_TYPE_ENUM = ::std::os::raw::c_int;
#[doc = " Holds information about the location of file content (or a file attribute). For most file systems, a file\n has only a single attribute that stores the file content.\n Other file systems, such as NTFS, have multiple\n attributes.  If multiple attributes exist, they are stored in a linked list.\n Attributes can be \"resident\", which means the data is stored\n in a small buffer instead of being stored in a full file system block.\n \"Non-resident\" attributes store data in blocks and they are stored in\n the data structure as a series of runs.\n This structure is used to represent both of these cases.\n\n The non-resident data has several size values.\n \\verbatim\n |--------------------------------------------------------------------|\n |skiplen|---------------allocsize------------------------------------|\n |skiplen|---------------size-----------------------------------|\n |skiplen|---------------initsize------------|\n \\endverbatim"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_ATTR {
    #[doc = "< Pointer to next attribute in list"]
    pub next: *mut TSK_FS_ATTR,
    #[doc = "< Pointer to the file that this is from"]
    pub fs_file: *mut TSK_FS_FILE,
    #[doc = "< Flags for attribute"]
    pub flags: TSK_FS_ATTR_FLAG_ENUM,
    #[doc = "< Name of attribute (in UTF-8).  Will be NULL if attribute doesn't have a name."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Number of bytes allocated to name"]
    pub name_size: usize,
    #[doc = "< Type of attribute"]
    pub type_: TSK_FS_ATTR_TYPE_ENUM,
    #[doc = "< Id of attribute"]
    pub id: u16,
    #[doc = "< Size in bytes of the attribute resident and non-resident content (does not include skiplen for non-resident attributes)"]
    pub size: TSK_OFF_T,
    pub nrd: TSK_FS_ATTR__bindgen_ty_1,
    pub rd: TSK_FS_ATTR__bindgen_ty_2,
    pub r: ::std::option::Option<
        unsafe extern "C" fn(
            fs_attr: *const TSK_FS_ATTR,
            a_offset: TSK_OFF_T,
            a_buf: *mut ::std::os::raw::c_char,
            a_len: usize,
        ) -> isize,
    >,
    pub w: ::std::option::Option<
        unsafe extern "C" fn(
            fs_attr: *const TSK_FS_ATTR,
            flags: ::std::os::raw::c_int,
            arg1: TSK_FS_FILE_WALK_CB,
            arg2: *mut ::std::os::raw::c_void,
        ) -> u8,
    >,
}
#[doc = " Data associated with a non-resident file / attribute.\n The data is stored in one or more data runs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_ATTR__bindgen_ty_1 {
    #[doc = "< Linked list of runs for non-resident attributes"]
    pub run: *mut TSK_FS_ATTR_RUN,
    #[doc = "< Pointer to final run in the list"]
    pub run_end: *mut TSK_FS_ATTR_RUN,
    #[doc = "< Number of initial bytes in run to skip before content begins. The size field does not include this length."]
    pub skiplen: u32,
    #[doc = "< Number of bytes that are allocated in all clusters of non-resident run (will be larger than size - does not include skiplen).  This is defined when the attribute is created and used to determine slack space."]
    pub allocsize: TSK_OFF_T,
    #[doc = "< Number of bytes (starting from offset 0) that have data (including FILLER) saved for them (smaller then or equal to size).  This is defined when the attribute is created."]
    pub initsize: TSK_OFF_T,
    #[doc = "< Size of compression units (needed only if NTFS file is compressed)"]
    pub compsize: u32,
}
#[doc = " Data associated with a resident attribute / file.\n The data is stored in a buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_ATTR__bindgen_ty_2 {
    #[doc = "< Buffer for resident data"]
    pub buf: *mut u8,
    #[doc = "< Number of bytes allocated to buf"]
    pub buf_size: usize,
    #[doc = "< Starting offset in bytes relative to start of file system (NOT YET IMPLEMENTED)"]
    pub offset: TSK_OFF_T,
}
#[doc = " Structure used as the head of an attribute list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_ATTRLIST {
    pub head: *mut TSK_FS_ATTR,
}
unsafe extern "C" {
    pub fn tsk_fs_attr_walk(
        a_fs_attr: *const TSK_FS_ATTR,
        a_flags: TSK_FS_FILE_WALK_FLAG_ENUM,
        a_action: TSK_FS_FILE_WALK_CB,
        a_ptr: *mut ::std::os::raw::c_void,
    ) -> u8;
}
#[doc = " Relatively generic structure to hold file names that are stored with\n the file metadata.  Note that this is different from the\n file name stored in the directory heirarchy, which is\n part of the tsk_fs_name_... code.  This is currently\n used for NTFS and FAT file systems only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_META_NAME_LIST {
    #[doc = "< Pointer to next name (or NULL)"]
    pub next: *mut TSK_FS_META_NAME_LIST,
    #[doc = "< Name in UTF-8 (does not include parent directory name)"]
    pub name: [::std::os::raw::c_char; 512usize],
    #[doc = "< Inode address of parent directory (NTFS only)"]
    pub par_inode: TSK_INUM_T,
    #[doc = "< Sequence number of parent directory (NTFS only)"]
    pub par_seq: u32,
}
#[doc = "< Metadata structure is currently in an allocated state"]
pub const TSK_FS_META_FLAG_ENUM_TSK_FS_META_FLAG_ALLOC: TSK_FS_META_FLAG_ENUM = 1;
#[doc = "< Metadata structure is currently in an unallocated state"]
pub const TSK_FS_META_FLAG_ENUM_TSK_FS_META_FLAG_UNALLOC: TSK_FS_META_FLAG_ENUM = 2;
#[doc = "< Metadata structure has been allocated at least once"]
pub const TSK_FS_META_FLAG_ENUM_TSK_FS_META_FLAG_USED: TSK_FS_META_FLAG_ENUM = 4;
#[doc = "< Metadata structure has never been allocated."]
pub const TSK_FS_META_FLAG_ENUM_TSK_FS_META_FLAG_UNUSED: TSK_FS_META_FLAG_ENUM = 8;
#[doc = "< The file contents are compressed."]
pub const TSK_FS_META_FLAG_ENUM_TSK_FS_META_FLAG_COMP: TSK_FS_META_FLAG_ENUM = 16;
#[doc = "< Return only metadata structures that have no file name pointing to the (inode_walk flag only)"]
pub const TSK_FS_META_FLAG_ENUM_TSK_FS_META_FLAG_ORPHAN: TSK_FS_META_FLAG_ENUM = 32;
#[doc = " Metadata flags used in TSK_FS_META.flags and in request to inode_walk"]
pub type TSK_FS_META_FLAG_ENUM = ::std::os::raw::c_int;
#[doc = "< The data in the attributes (if any) is not for this file"]
pub const TSK_FS_META_ATTR_FLAG_ENUM_TSK_FS_META_ATTR_EMPTY: TSK_FS_META_ATTR_FLAG_ENUM = 0;
#[doc = "< The data in the attributes are for this file"]
pub const TSK_FS_META_ATTR_FLAG_ENUM_TSK_FS_META_ATTR_STUDIED: TSK_FS_META_ATTR_FLAG_ENUM = 1;
#[doc = "< The attributes for this file could not be loaded"]
pub const TSK_FS_META_ATTR_FLAG_ENUM_TSK_FS_META_ATTR_ERROR: TSK_FS_META_ATTR_FLAG_ENUM = 2;
pub type TSK_FS_META_ATTR_FLAG_ENUM = ::std::os::raw::c_int;
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_UNDEF: TSK_FS_META_TYPE_ENUM = 0;
#[doc = "< Regular file"]
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_REG: TSK_FS_META_TYPE_ENUM = 1;
#[doc = "< Directory file"]
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_DIR: TSK_FS_META_TYPE_ENUM = 2;
#[doc = "< Named pipe (fifo)"]
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_FIFO: TSK_FS_META_TYPE_ENUM = 3;
#[doc = "< Character device"]
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_CHR: TSK_FS_META_TYPE_ENUM = 4;
#[doc = "< Block device"]
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_BLK: TSK_FS_META_TYPE_ENUM = 5;
#[doc = "< Symbolic link"]
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_LNK: TSK_FS_META_TYPE_ENUM = 6;
#[doc = "< SOLARIS ONLY"]
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_SHAD: TSK_FS_META_TYPE_ENUM = 7;
#[doc = "< UNIX domain socket"]
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_SOCK: TSK_FS_META_TYPE_ENUM = 8;
#[doc = "< Whiteout"]
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_WHT: TSK_FS_META_TYPE_ENUM = 9;
#[doc = "< \"Virtual File\" created by TSK for file system areas"]
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_VIRT: TSK_FS_META_TYPE_ENUM = 10;
#[doc = "< \"Virtual Directory\" created by TSK to hold data like orphan files"]
pub const TSK_FS_META_TYPE_ENUM_TSK_FS_META_TYPE_VIRT_DIR: TSK_FS_META_TYPE_ENUM = 11;
#[doc = " Values for the mode field -- which identifies the file type\n and permissions."]
pub type TSK_FS_META_TYPE_ENUM = ::std::os::raw::c_int;
#[doc = "< unspecified"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_UNSPECIFIED: TSK_FS_META_MODE_ENUM = 0;
#[doc = "< set user id on execution"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_ISUID: TSK_FS_META_MODE_ENUM = 2048;
#[doc = "< set group id on execution"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_ISGID: TSK_FS_META_MODE_ENUM = 1024;
#[doc = "< sticky bit"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_ISVTX: TSK_FS_META_MODE_ENUM = 512;
#[doc = "< R for owner"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_IRUSR: TSK_FS_META_MODE_ENUM = 256;
#[doc = "< W for owner"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_IWUSR: TSK_FS_META_MODE_ENUM = 128;
#[doc = "< X for owner"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_IXUSR: TSK_FS_META_MODE_ENUM = 64;
#[doc = "< R for group"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_IRGRP: TSK_FS_META_MODE_ENUM = 32;
#[doc = "< W for group"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_IWGRP: TSK_FS_META_MODE_ENUM = 16;
#[doc = "< X for group"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_IXGRP: TSK_FS_META_MODE_ENUM = 8;
#[doc = "< R for other"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_IROTH: TSK_FS_META_MODE_ENUM = 4;
#[doc = "< W for other"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_IWOTH: TSK_FS_META_MODE_ENUM = 2;
#[doc = "< X for other"]
pub const TSK_FS_META_MODE_ENUM_TSK_FS_META_MODE_IXOTH: TSK_FS_META_MODE_ENUM = 1;
pub type TSK_FS_META_MODE_ENUM = ::std::os::raw::c_int;
pub const TSK_FS_META_CONTENT_TYPE_ENUM_TSK_FS_META_CONTENT_TYPE_DEFAULT:
    TSK_FS_META_CONTENT_TYPE_ENUM = 0;
#[doc = "< Ext4 with extents instead of individual pointers"]
pub const TSK_FS_META_CONTENT_TYPE_ENUM_TSK_FS_META_CONTENT_TYPE_EXT4_EXTENTS:
    TSK_FS_META_CONTENT_TYPE_ENUM = 1;
#[doc = "< Ext4 with inline data"]
pub const TSK_FS_META_CONTENT_TYPE_ENUM_TSK_FS_META_CONTENT_TYPE_EXT4_INLINE:
    TSK_FS_META_CONTENT_TYPE_ENUM = 2;
pub const TSK_FS_META_CONTENT_TYPE_ENUM_TSK_FS_META_CONTENT_TYPE_XFS_DATA_FORK_SHORTFORM:
    TSK_FS_META_CONTENT_TYPE_ENUM = 3;
pub const TSK_FS_META_CONTENT_TYPE_ENUM_TSK_FS_META_CONTENT_TYPE_XFS_DATA_FORK_EXTENTS:
    TSK_FS_META_CONTENT_TYPE_ENUM = 4;
pub const TSK_FS_META_CONTENT_TYPE_ENUM_TSK_FS_META_CONTENT_TYPE_XFS_DATA_FORK_BTREE:
    TSK_FS_META_CONTENT_TYPE_ENUM = 5;
pub type TSK_FS_META_CONTENT_TYPE_ENUM = ::std::os::raw::c_int;
#[doc = " TSK data structure to store general file and directory metadata.\n Note that the file in the file\n system may have more metadata than is stored here.\n For performance reasons, the run list of the file content is not always known\n when the file is loaded.  It may be loaded only when needed by the internal code.\n The TSK_FS_META::content_ptr pointer contains file system-specific data that will be\n used to determine the full run. After it has been loaded, the TSK_FS_META::attr field\n will contain that info."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TSK_FS_META {
    #[doc = "< \\internal Will be set to TSK_FS_META_TAG if structure is allocated"]
    pub tag: ::std::os::raw::c_int,
    #[doc = "< Flags for this file for its allocation status etc."]
    pub flags: TSK_FS_META_FLAG_ENUM,
    #[doc = "< Address of the meta data structure for this file"]
    pub addr: TSK_INUM_T,
    #[doc = "< File type"]
    pub type_: TSK_FS_META_TYPE_ENUM,
    #[doc = "< Unix-style permissions"]
    pub mode: TSK_FS_META_MODE_ENUM,
    #[doc = "< link count (number of file names pointing to this)"]
    pub nlink: ::std::os::raw::c_int,
    #[doc = "< file size (in bytes)"]
    pub size: TSK_OFF_T,
    #[doc = "< address within file system where inode structure begins"]
    pub start_of_inode: TSK_OFF_T,
    #[doc = "< owner id"]
    pub uid: TSK_UID_T,
    #[doc = "< group id"]
    pub gid: TSK_GID_T,
    #[doc = "< last file content modification time (stored in number of seconds since Jan 1, 1970 UTC)"]
    pub mtime: time_t,
    #[doc = "< nano-second resolution in addition to m_time"]
    pub mtime_nano: u32,
    #[doc = "< last file content accessed time (stored in number of seconds since Jan 1, 1970 UTC)"]
    pub atime: time_t,
    #[doc = "< nano-second resolution in addition to a_time"]
    pub atime_nano: u32,
    #[doc = "< last file / metadata status change time (stored in number of seconds since Jan 1, 1970 UTC)"]
    pub ctime: time_t,
    #[doc = "< nano-second resolution in addition to c_time"]
    pub ctime_nano: u32,
    #[doc = "< Created time (stored in number of seconds since Jan 1, 1970 UTC)"]
    pub crtime: time_t,
    #[doc = "< nano-second resolution in addition to cr_time"]
    pub crtime_nano: u32,
    pub time2: TSK_FS_META__bindgen_ty_1,
    #[doc = "< Pointer to file system specific data that is used to store references to file content"]
    pub content_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< size of content  buffer"]
    pub content_len: usize,
    #[doc = "< File system-specific and describes type of data in content_ptr in case file systems have multiple ways of storing things."]
    pub content_type: TSK_FS_META_CONTENT_TYPE_ENUM,
    #[doc = "< \\internal Optional callback used for any internal cleanup needed before freeing content_ptr"]
    pub reset_content:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    #[doc = "< Sequence number for file (NTFS only, is incremented when entry is reallocated)"]
    pub seq: u32,
    #[doc = " Contains run data on the file content (specific locations where content is stored).\n Check attr_state to determine if data in here is valid because not all file systems\n load this data when a file is loaded.  It may not be loaded until needed by one\n of the APIs. Most file systems will have only one attribute, but NTFS will have several."]
    pub attr: *mut TSK_FS_ATTRLIST,
    #[doc = "< State of the data in the TSK_FS_META::attr structure"]
    pub attr_state: TSK_FS_META_ATTR_FLAG_ENUM,
    #[doc = "< Name of file stored in metadata (FATXX and NTFS Only)"]
    pub name2: *mut TSK_FS_META_NAME_LIST,
    #[doc = "< Name of target file if this is a symbolic link"]
    pub link: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TSK_FS_META__bindgen_ty_1 {
    pub ext2: TSK_FS_META__bindgen_ty_1__bindgen_ty_1,
    pub hfs: TSK_FS_META__bindgen_ty_1__bindgen_ty_2,
    pub ntfs: TSK_FS_META__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_META__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Linux deletion time"]
    pub dtime: time_t,
    #[doc = "< nano-second resolution in addition to d_time"]
    pub dtime_nano: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_META__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< HFS+ backup time"]
    pub bkup_time: time_t,
    #[doc = "< nano-second resolution in addition to bkup_time"]
    pub bkup_time_nano: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_META__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< NTFS Created time stored in FILE_NAME"]
    pub fn_crtime: time_t,
    #[doc = "< NTFS Created time stored in FILE_NAME in nano-second resolution"]
    pub fn_crtime_nano: time_t,
    #[doc = "< NTFS mod (content) stored in FILE_NAME"]
    pub fn_mtime: time_t,
    #[doc = "< NTFS mod time stored in FILE_NAME in nano-second resolution"]
    pub fn_mtime_nano: time_t,
    #[doc = "< NTFS access time stored in FILE_NAME"]
    pub fn_atime: time_t,
    #[doc = "< NTFS access time stored in FILE_NAME in nano-second resolution"]
    pub fn_atime_nano: time_t,
    #[doc = "< NTFS change (MFT Entry) time stored in FILE_NAME"]
    pub fn_ctime: time_t,
    #[doc = "< NTFS change (MFT Entry) time stored in FILE_NAME in nano-second resolution"]
    pub fn_ctime_nano: time_t,
    #[doc = "< Attribute ID used to populate FN times."]
    pub fn_id: u16,
}
#[doc = " inode walk callback function definition.  This is called for every file\n that meets the criteria specified when inode_walk was called.\n @param a_fs_file Pointer to the current file\n @param a_ptr Pointer that was specified by caller to inode_walk\n @returns Value that tells inode walk to continue or stop"]
pub type TSK_FS_META_WALK_CB = ::std::option::Option<
    unsafe extern "C" fn(
        a_fs_file: *mut TSK_FS_FILE,
        a_ptr: *mut ::std::os::raw::c_void,
    ) -> TSK_WALK_RET_ENUM,
>;
unsafe extern "C" {
    pub fn tsk_fs_meta_walk(
        a_fs: *mut TSK_FS_INFO,
        a_start: TSK_INUM_T,
        a_end: TSK_INUM_T,
        a_flags: TSK_FS_META_FLAG_ENUM,
        a_cb: TSK_FS_META_WALK_CB,
        a_ptr: *mut ::std::os::raw::c_void,
    ) -> u8;
}
unsafe extern "C" {
    pub fn tsk_fs_meta_make_ls(
        a_fs_meta: *const TSK_FS_META,
        a_buf: *mut ::std::os::raw::c_char,
        a_len: usize,
    ) -> u8;
}
#[doc = "< Name is in an allocated state"]
pub const TSK_FS_NAME_FLAG_ENUM_TSK_FS_NAME_FLAG_ALLOC: TSK_FS_NAME_FLAG_ENUM = 1;
#[doc = "< Name is in an unallocated state"]
pub const TSK_FS_NAME_FLAG_ENUM_TSK_FS_NAME_FLAG_UNALLOC: TSK_FS_NAME_FLAG_ENUM = 2;
#[doc = " File name flags that are used when specifying the status of\n a name in the TSK_FS_NAME structure"]
pub type TSK_FS_NAME_FLAG_ENUM = ::std::os::raw::c_int;
#[doc = "< Unknown type"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_UNDEF: TSK_FS_NAME_TYPE_ENUM = 0;
#[doc = "< Named pipe"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_FIFO: TSK_FS_NAME_TYPE_ENUM = 1;
#[doc = "< Character device"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_CHR: TSK_FS_NAME_TYPE_ENUM = 2;
#[doc = "< Directory"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_DIR: TSK_FS_NAME_TYPE_ENUM = 3;
#[doc = "< Block device"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_BLK: TSK_FS_NAME_TYPE_ENUM = 4;
#[doc = "< Regular file"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_REG: TSK_FS_NAME_TYPE_ENUM = 5;
#[doc = "< Symbolic link"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_LNK: TSK_FS_NAME_TYPE_ENUM = 6;
#[doc = "< Socket"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_SOCK: TSK_FS_NAME_TYPE_ENUM = 7;
#[doc = "< Shadow inode (solaris)"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_SHAD: TSK_FS_NAME_TYPE_ENUM = 8;
#[doc = "< Whiteout (openbsd)"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_WHT: TSK_FS_NAME_TYPE_ENUM = 9;
#[doc = "< Special (TSK added \"Virtual\" files)"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_VIRT: TSK_FS_NAME_TYPE_ENUM = 10;
#[doc = "< Special (TSK added \"Virtual\" directories)"]
pub const TSK_FS_NAME_TYPE_ENUM_TSK_FS_NAME_TYPE_VIRT_DIR: TSK_FS_NAME_TYPE_ENUM = 11;
#[doc = " File type values -- as specified in the directory entry structure."]
pub type TSK_FS_NAME_TYPE_ENUM = ::std::os::raw::c_int;
#[doc = " Generic structure to store the file name information that is stored in\n a directory. Most file systems separate the file name from the metadata, but\n some do not (such as FAT). This structure contains the name and address of the\n metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_NAME {
    #[doc = "< \\internal Set to TSK_FS_NAME_ID if allocated, 0 if not"]
    pub tag: ::std::os::raw::c_int,
    #[doc = "< The name of the file (in UTF-8)"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< The number of bytes allocated to name"]
    pub name_size: usize,
    #[doc = "< The short name of the file or null (in UTF-8)"]
    pub shrt_name: *mut ::std::os::raw::c_char,
    #[doc = "< The number of bytes allocated to shrt_name"]
    pub shrt_name_size: usize,
    #[doc = "< Address of the metadata structure that the name points to."]
    pub meta_addr: TSK_INUM_T,
    #[doc = "< Sequence number for metadata structure (NTFS only)"]
    pub meta_seq: u32,
    #[doc = "< Metadata address of parent directory (equal to meta_addr if this entry is for root directory)."]
    pub par_addr: TSK_INUM_T,
    #[doc = "< Sequence number for parent directory (NTFS only)"]
    pub par_seq: u32,
    #[doc = "< Time entry was added to a directory (APFS only)"]
    pub date_added: u64,
    #[doc = "< File type information (directory, file, etc.)"]
    pub type_: TSK_FS_NAME_TYPE_ENUM,
    #[doc = "< Flags that describe allocation status etc."]
    pub flags: TSK_FS_NAME_FLAG_ENUM,
}
#[doc = " Definition of callback function that is used by tsk_fs_dir_walk().  This is\n is called for each file in a directory.\n @param a_fs_file Pointer to the current file in the directory\n @param a_path Path of the file\n @param a_ptr Pointer that was originally passed by caller to tsk_fs_dir_walk.\n @returns Value to signal if tsk_fs_dir_walk should stop or continue."]
pub type TSK_FS_DIR_WALK_CB = ::std::option::Option<
    unsafe extern "C" fn(
        a_fs_file: *mut TSK_FS_FILE,
        a_path: *const ::std::os::raw::c_char,
        a_ptr: *mut ::std::os::raw::c_void,
    ) -> TSK_WALK_RET_ENUM,
>;
#[doc = " A handle to a directory so that its files can be individually accessed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_DIR {
    #[doc = "< \\internal Will be set to TSK_FS_DIR_TAG if structure is still allocated, 0 if not"]
    pub tag: ::std::os::raw::c_int,
    #[doc = "< Pointer to the file structure for the directory."]
    pub fs_file: *mut TSK_FS_FILE,
    #[doc = "< Pointer to list of names in directory."]
    pub names: *mut TSK_FS_NAME,
    #[doc = "< Number of name structures in queue being used"]
    pub names_used: usize,
    #[doc = "< Number of name structures that were allocated"]
    pub names_alloc: usize,
    #[doc = "< Metadata address of this directory"]
    pub addr: TSK_INUM_T,
    #[doc = "< Metadata address sequence (NTFS Only)"]
    pub seq: u32,
    #[doc = "< Pointer to file system the directory is located in"]
    pub fs_info: *mut TSK_FS_INFO,
}
#[doc = "< No Flags"]
pub const TSK_FS_DIR_WALK_FLAG_ENUM_TSK_FS_DIR_WALK_FLAG_NONE: TSK_FS_DIR_WALK_FLAG_ENUM = 0;
#[doc = "< Return allocated names in callback"]
pub const TSK_FS_DIR_WALK_FLAG_ENUM_TSK_FS_DIR_WALK_FLAG_ALLOC: TSK_FS_DIR_WALK_FLAG_ENUM = 1;
#[doc = "< Return unallocated names in callback"]
pub const TSK_FS_DIR_WALK_FLAG_ENUM_TSK_FS_DIR_WALK_FLAG_UNALLOC: TSK_FS_DIR_WALK_FLAG_ENUM = 2;
#[doc = "< Recurse into sub-directories"]
pub const TSK_FS_DIR_WALK_FLAG_ENUM_TSK_FS_DIR_WALK_FLAG_RECURSE: TSK_FS_DIR_WALK_FLAG_ENUM = 4;
#[doc = "< Do not return (or recurse into) the special Orphan directory"]
pub const TSK_FS_DIR_WALK_FLAG_ENUM_TSK_FS_DIR_WALK_FLAG_NOORPHAN: TSK_FS_DIR_WALK_FLAG_ENUM = 8;
#[doc = " Flags that are used when walking names in directories.  These are used to identify\n which files to call the callback function on."]
pub type TSK_FS_DIR_WALK_FLAG_ENUM = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn tsk_fs_dir_open_meta(a_fs: *mut TSK_FS_INFO, a_addr: TSK_INUM_T) -> *mut TSK_FS_DIR;
}
unsafe extern "C" {
    pub fn tsk_fs_dir_open(
        a_fs: *mut TSK_FS_INFO,
        a_dir: *const ::std::os::raw::c_char,
    ) -> *mut TSK_FS_DIR;
}
unsafe extern "C" {
    pub fn tsk_fs_dir_walk(
        a_fs: *mut TSK_FS_INFO,
        a_inode: TSK_INUM_T,
        a_flags: TSK_FS_DIR_WALK_FLAG_ENUM,
        a_action: TSK_FS_DIR_WALK_CB,
        a_ptr: *mut ::std::os::raw::c_void,
    ) -> u8;
}
unsafe extern "C" {
    pub fn tsk_fs_dir_getsize(arg1: *const TSK_FS_DIR) -> usize;
}
unsafe extern "C" {
    pub fn tsk_fs_dir_get(arg1: *const TSK_FS_DIR, arg2: usize) -> *mut TSK_FS_FILE;
}
unsafe extern "C" {
    pub fn tsk_fs_dir_get2(
        arg1: *const TSK_FS_DIR,
        arg2: usize,
        load_attributes: usize,
    ) -> *mut TSK_FS_FILE;
}
unsafe extern "C" {
    pub fn tsk_fs_dir_get_name(a_fs_dir: *const TSK_FS_DIR, a_idx: usize) -> *const TSK_FS_NAME;
}
unsafe extern "C" {
    pub fn tsk_fs_dir_close(arg1: *mut TSK_FS_DIR);
}
unsafe extern "C" {
    pub fn tsk_fs_path2inum(
        a_fs: *mut TSK_FS_INFO,
        a_path: *const ::std::os::raw::c_char,
        a_result: *mut TSK_INUM_T,
        a_fs_name: *mut TSK_FS_NAME,
    ) -> i8;
}
#[doc = " Generic structure used to refer to files in the file system.  A file will\n typically have a name and metadata.  This structure holds that type of information.\n When deleted files are being processed, this structure may have the name defined\n but not metadata because it no longer exists. Or, if you are calling meta_walk\n and are not processing at the name level, then the name will not be defined.\n always check these to make sure they are not null before they are read."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_FILE {
    #[doc = "< \\internal Will be set to TSK_FS_FILE_TAG if structure is allocated"]
    pub tag: ::std::os::raw::c_int,
    #[doc = "< Pointer to name of file (or NULL if file was opened using metadata address)"]
    pub name: *mut TSK_FS_NAME,
    #[doc = "< Pointer to metadata of file (or NULL if name has invalid metadata address)"]
    pub meta: *mut TSK_FS_META,
    #[doc = "< Pointer to file system that the file is located in."]
    pub fs_info: *mut TSK_FS_INFO,
}
#[doc = "< No Flags"]
pub const TSK_FS_FILE_READ_FLAG_ENUM_TSK_FS_FILE_READ_FLAG_NONE: TSK_FS_FILE_READ_FLAG_ENUM = 0;
#[doc = "< Allow read access into slack space"]
pub const TSK_FS_FILE_READ_FLAG_ENUM_TSK_FS_FILE_READ_FLAG_SLACK: TSK_FS_FILE_READ_FLAG_ENUM = 1;
#[doc = "< Ignore the Id argument given in the API (use only the type)"]
pub const TSK_FS_FILE_READ_FLAG_ENUM_TSK_FS_FILE_READ_FLAG_NOID: TSK_FS_FILE_READ_FLAG_ENUM = 2;
#[doc = " Flags used by tsk_fs_file_read"]
pub type TSK_FS_FILE_READ_FLAG_ENUM = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn tsk_fs_file_close(a_fs_file: *mut TSK_FS_FILE);
}
unsafe extern "C" {
    pub fn tsk_fs_file_open(
        a_fs: *mut TSK_FS_INFO,
        a_fs_file: *mut TSK_FS_FILE,
        a_path: *const ::std::os::raw::c_char,
    ) -> *mut TSK_FS_FILE;
}
unsafe extern "C" {
    pub fn tsk_fs_file_open_meta(
        fs: *mut TSK_FS_INFO,
        fs_file: *mut TSK_FS_FILE,
        addr: TSK_INUM_T,
    ) -> *mut TSK_FS_FILE;
}
unsafe extern "C" {
    pub fn tsk_fs_file_read(
        arg1: *mut TSK_FS_FILE,
        arg2: TSK_OFF_T,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
        arg5: TSK_FS_FILE_READ_FLAG_ENUM,
    ) -> isize;
}
unsafe extern "C" {
    pub fn tsk_fs_file_read_type(
        arg1: *mut TSK_FS_FILE,
        arg2: TSK_FS_ATTR_TYPE_ENUM,
        arg3: u16,
        arg4: TSK_OFF_T,
        arg5: *mut ::std::os::raw::c_char,
        arg6: usize,
        arg7: TSK_FS_FILE_READ_FLAG_ENUM,
    ) -> isize;
}
unsafe extern "C" {
    pub fn tsk_fs_file_attr_get(a_fs_file: *mut TSK_FS_FILE) -> *const TSK_FS_ATTR;
}
unsafe extern "C" {
    pub fn tsk_fs_file_attr_getsize(a_fs_file: *mut TSK_FS_FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tsk_fs_file_attr_get_idx(
        a_fs_file: *mut TSK_FS_FILE,
        a_idx: ::std::os::raw::c_int,
    ) -> *const TSK_FS_ATTR;
}
unsafe extern "C" {
    pub fn tsk_fs_file_attr_get_type(
        a_fs_file: *mut TSK_FS_FILE,
        arg1: TSK_FS_ATTR_TYPE_ENUM,
        arg2: u16,
        arg3: u8,
    ) -> *const TSK_FS_ATTR;
}
unsafe extern "C" {
    pub fn tsk_fs_file_attr_get_id(a_fs_file: *mut TSK_FS_FILE, arg1: u16) -> *const TSK_FS_ATTR;
}
unsafe extern "C" {
    pub fn tsk_fs_file_walk(
        a_fs_file: *mut TSK_FS_FILE,
        a_flags: TSK_FS_FILE_WALK_FLAG_ENUM,
        a_action: TSK_FS_FILE_WALK_CB,
        a_ptr: *mut ::std::os::raw::c_void,
    ) -> u8;
}
unsafe extern "C" {
    pub fn tsk_fs_file_walk_type(
        a_fs_file: *mut TSK_FS_FILE,
        a_type: TSK_FS_ATTR_TYPE_ENUM,
        a_id: u16,
        a_flags: TSK_FS_FILE_WALK_FLAG_ENUM,
        a_action: TSK_FS_FILE_WALK_CB,
        a_ptr: *mut ::std::os::raw::c_void,
    ) -> u8;
}
unsafe extern "C" {
    pub fn tsk_fs_attr_read(
        a_fs_attr: *const TSK_FS_ATTR,
        a_offset: TSK_OFF_T,
        a_buf: *mut ::std::os::raw::c_char,
        a_len: usize,
        a_flags: TSK_FS_FILE_READ_FLAG_ENUM,
    ) -> isize;
}
unsafe extern "C" {
    pub fn tsk_fs_file_get_owner_sid(
        arg1: *mut TSK_FS_FILE,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_HASH_RESULTS {
    pub flags: TSK_BASE_HASH_ENUM,
    pub md5_digest: [::std::os::raw::c_uchar; 16usize],
    pub sha1_digest: [::std::os::raw::c_uchar; 20usize],
}
unsafe extern "C" {
    pub fn tsk_fs_file_hash_calc(
        arg1: *mut TSK_FS_FILE,
        arg2: *mut TSK_FS_HASH_RESULTS,
        arg3: TSK_BASE_HASH_ENUM,
    ) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_JENTRY {
    pub jblk: TSK_DADDR_T,
    pub fsblk: TSK_DADDR_T,
}
pub type TSK_FS_JBLK_WALK_CB = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut TSK_FS_INFO,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
    ) -> TSK_WALK_RET_ENUM,
>;
pub type TSK_FS_JENTRY_WALK_CB = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut TSK_FS_INFO,
        arg2: *mut TSK_FS_JENTRY,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
    ) -> TSK_WALK_RET_ENUM,
>;
#[doc = "< Use autodetection methods"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_DETECT: TSK_FS_TYPE_ENUM = 0;
#[doc = "< NTFS file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_NTFS: TSK_FS_TYPE_ENUM = 1;
#[doc = "< NTFS auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_NTFS_DETECT: TSK_FS_TYPE_ENUM = 1;
#[doc = "< FAT12 file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_FAT12: TSK_FS_TYPE_ENUM = 2;
#[doc = "< FAT16 file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_FAT16: TSK_FS_TYPE_ENUM = 4;
#[doc = "< FAT32 file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_FAT32: TSK_FS_TYPE_ENUM = 8;
#[doc = "< exFAT file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_EXFAT: TSK_FS_TYPE_ENUM = 10;
#[doc = "< FAT auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_FAT_DETECT: TSK_FS_TYPE_ENUM = 14;
#[doc = "< UFS1 (FreeBSD, OpenBSD, BSDI ...)"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_FFS1: TSK_FS_TYPE_ENUM = 16;
#[doc = "< UFS1b (Solaris - has no type)"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_FFS1B: TSK_FS_TYPE_ENUM = 32;
#[doc = "< UFS2 - FreeBSD, NetBSD"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_FFS2: TSK_FS_TYPE_ENUM = 64;
#[doc = "< UFS auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_FFS_DETECT: TSK_FS_TYPE_ENUM = 112;
#[doc = "< Ext2 file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_EXT2: TSK_FS_TYPE_ENUM = 128;
#[doc = "< Ext3 file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_EXT3: TSK_FS_TYPE_ENUM = 256;
#[doc = "< ExtX auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_EXT_DETECT: TSK_FS_TYPE_ENUM = 8576;
#[doc = "< SWAP file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_SWAP: TSK_FS_TYPE_ENUM = 512;
#[doc = "< SWAP auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_SWAP_DETECT: TSK_FS_TYPE_ENUM = 512;
#[doc = "< RAW file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_RAW: TSK_FS_TYPE_ENUM = 1024;
#[doc = "< RAW auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_RAW_DETECT: TSK_FS_TYPE_ENUM = 1024;
#[doc = "< ISO9660 file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_ISO9660: TSK_FS_TYPE_ENUM = 2048;
#[doc = "< ISO9660 auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_ISO9660_DETECT: TSK_FS_TYPE_ENUM = 2048;
#[doc = "< HFS+/HFSX file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_HFS: TSK_FS_TYPE_ENUM = 4096;
#[doc = "< HFS auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_HFS_DETECT: TSK_FS_TYPE_ENUM = 36864;
#[doc = "< Ext4 file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_EXT4: TSK_FS_TYPE_ENUM = 8192;
#[doc = "< YAFFS2 file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_YAFFS2: TSK_FS_TYPE_ENUM = 16384;
#[doc = "< YAFFS2 auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_YAFFS2_DETECT: TSK_FS_TYPE_ENUM = 16384;
#[doc = "< HFS file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_HFS_LEGACY: TSK_FS_TYPE_ENUM = 32768;
#[doc = "< APFS file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_APFS: TSK_FS_TYPE_ENUM = 65536;
#[doc = "< APFS auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_APFS_DETECT: TSK_FS_TYPE_ENUM = 65536;
#[doc = "< Logical directory (aut detection not supported)"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_LOGICAL: TSK_FS_TYPE_ENUM = 131072;
#[doc = "< Btrfs file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_BTRFS: TSK_FS_TYPE_ENUM = 262144;
#[doc = "< Btrfs auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_BTRFS_DETECT: TSK_FS_TYPE_ENUM = 262144;
#[doc = "< XFS file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_XFS: TSK_FS_TYPE_ENUM = 524288;
#[doc = "< XFS auto detection"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_XFS_DETECT: TSK_FS_TYPE_ENUM = 524288;
#[doc = "< Unsupported file system"]
pub const TSK_FS_TYPE_ENUM_TSK_FS_TYPE_UNSUPP: TSK_FS_TYPE_ENUM = -1;
#[doc = " Values for the file system type.  Each bit corresponds to a file\n system. The \"[fs]_DETECT\" value (such as TSK_FS_TYPE_NTSF_DETECT) is\n the OR of all of the subtypes that\n it could detect.  If there is only one type of that file system,\n the [fs]_DETECT value will be the same as the type.\n\n The _DETECT values should not be stored in TSK_FS_INFO.  Once\n tsk_fs_open() has detected the type, it should assign the specific\n version in TSK_FS_INFO.\n"]
pub type TSK_FS_TYPE_ENUM = ::std::os::raw::c_int;
#[doc = "< No Flags"]
pub const TSK_FS_INFO_FLAG_ENUM_TSK_FS_INFO_FLAG_NONE: TSK_FS_INFO_FLAG_ENUM = 0;
#[doc = "< File system has sequence numbers in the inode addresses."]
pub const TSK_FS_INFO_FLAG_ENUM_TSK_FS_INFO_FLAG_HAVE_SEQ: TSK_FS_INFO_FLAG_ENUM = 1;
#[doc = "< Nano second field in times will be set."]
pub const TSK_FS_INFO_FLAG_ENUM_TSK_FS_INFO_FLAG_HAVE_NANOSEC: TSK_FS_INFO_FLAG_ENUM = 2;
#[doc = "< File system is encrypted"]
pub const TSK_FS_INFO_FLAG_ENUM_TSK_FS_INFO_FLAG_ENCRYPTED: TSK_FS_INFO_FLAG_ENUM = 4;
#[doc = " Flags for the FS_INFO structure"]
pub type TSK_FS_INFO_FLAG_ENUM = ::std::os::raw::c_int;
pub const TSK_FS_ISTAT_FLAG_ENUM_TSK_FS_ISTAT_NONE: TSK_FS_ISTAT_FLAG_ENUM = 0;
pub const TSK_FS_ISTAT_FLAG_ENUM_TSK_FS_ISTAT_RUNLIST: TSK_FS_ISTAT_FLAG_ENUM = 1;
pub type TSK_FS_ISTAT_FLAG_ENUM = ::std::os::raw::c_int;
pub const TSK_FS_ENCRYPTION_TYPE_ENUM_TSK_FS_ENCRYPTION_TYPE_NONE: TSK_FS_ENCRYPTION_TYPE_ENUM = 0;
pub const TSK_FS_ENCRYPTION_TYPE_ENUM_TSK_FS_ENCRYPTION_TYPE_BITLOCKER:
    TSK_FS_ENCRYPTION_TYPE_ENUM = 1;
pub type TSK_FS_ENCRYPTION_TYPE_ENUM = ::std::os::raw::c_int;
#[doc = " Stores state information for an open file system.\n One of these are generated for each open files system and it contains\n file system-type specific data.  These values are all filled in by\n the file system code and not the caller functions.  This struct\n (and its subclasses) should be allocated only by tsk_fs_malloc\n and deallocated only by tsk_fs_free, which handle init/deinit\n of the locks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_INFO {
    #[doc = "< \\internal Will be set to TSK_FS_INFO_TAG if structure is still allocated, 0 if not"]
    pub tag: ::std::os::raw::c_int,
    pub __bindgen_anon_1: TSK_FS_INFO__bindgen_ty_1,
    #[doc = "< Number of metadata addresses"]
    pub inum_count: TSK_INUM_T,
    #[doc = "< Metadata address of root directory"]
    pub root_inum: TSK_INUM_T,
    #[doc = "< First valid metadata address"]
    pub first_inum: TSK_INUM_T,
    #[doc = "< Last valid metadata address"]
    pub last_inum: TSK_INUM_T,
    #[doc = "< Number of blocks in fs"]
    pub block_count: TSK_DADDR_T,
    #[doc = "< Address of first block"]
    pub first_block: TSK_DADDR_T,
    #[doc = "< Address of last block as reported by file system (could be larger than last_block in image if end of image does not exist)"]
    pub last_block: TSK_DADDR_T,
    #[doc = "< Address of last block -- adjusted so that it is equal to the last block in the image or volume (if image is not complete)"]
    pub last_block_act: TSK_DADDR_T,
    #[doc = "< Size of each block (in bytes)"]
    pub block_size: ::std::os::raw::c_uint,
    #[doc = "< Size of device block (typically always 512)"]
    pub dev_bsize: ::std::os::raw::c_uint,
    #[doc = "< Number of bytes that precede each block (currently only used for RAW CDs)"]
    pub block_pre_size: ::std::os::raw::c_uint,
    #[doc = "< Number of bytes that follow each block (currently only used for RAW CDs)"]
    pub block_post_size: ::std::os::raw::c_uint,
    #[doc = "< Address of journal inode"]
    pub journ_inum: TSK_INUM_T,
    #[doc = "< type of file system"]
    pub ftype: TSK_FS_TYPE_ENUM,
    #[doc = "< string \"name\" of data unit type"]
    pub duname: *const ::std::os::raw::c_char,
    #[doc = "< flags for file system"]
    pub flags: TSK_FS_INFO_FLAG_ENUM,
    #[doc = "< File system id (as reported in boot sector)"]
    pub fs_id: [u8; 32usize],
    #[doc = "< Number of bytes in fs_id that are being used"]
    pub fs_id_used: usize,
    #[doc = "< Endian order of data"]
    pub endian: TSK_ENDIAN_ENUM,
    pub list_inum_named_lock: tsk_lock_t,
    #[doc = "< List of unallocated inodes that\n are pointed to by a file name --\n Used to find orphan files.  Is filled\n after looking for orphans\n or afer a full name_walk is performed.\n (r/w shared - lock)"]
    pub list_inum_named: *mut TSK_LIST,
    pub encryption_type: TSK_FS_ENCRYPTION_TYPE_ENUM,
    pub encryption_data: *mut ::std::os::raw::c_void,
    pub orphan_dir_lock: tsk_lock_t,
    #[doc = "< Files and dirs in the top level of the $OrphanFiles directory.  NULL if orphans have not been hunted for yet. (r/w shared - lock)"]
    pub orphan_dir: *mut TSK_FS_DIR,
    #[doc = "< FS-specific function: Call tsk_fs_block_walk() instead."]
    pub block_walk: ::std::option::Option<
        unsafe extern "C" fn(
            fs: *mut TSK_FS_INFO,
            start: TSK_DADDR_T,
            end: TSK_DADDR_T,
            flags: TSK_FS_BLOCK_WALK_FLAG_ENUM,
            cb: TSK_FS_BLOCK_WALK_CB,
            ptr: *mut ::std::os::raw::c_void,
        ) -> u8,
    >,
    #[doc = "< \\internal"]
    pub block_getflags: ::std::option::Option<
        unsafe extern "C" fn(a_fs: *mut TSK_FS_INFO, a_addr: TSK_DADDR_T) -> TSK_FS_BLOCK_FLAG_ENUM,
    >,
    #[doc = "< FS-specific function: Call tsk_fs_meta_walk() instead."]
    pub inode_walk: ::std::option::Option<
        unsafe extern "C" fn(
            fs: *mut TSK_FS_INFO,
            start: TSK_INUM_T,
            end: TSK_INUM_T,
            flags: TSK_FS_META_FLAG_ENUM,
            cb: TSK_FS_META_WALK_CB,
            ptr: *mut ::std::os::raw::c_void,
        ) -> u8,
    >,
    #[doc = "< \\internal"]
    pub file_add_meta: ::std::option::Option<
        unsafe extern "C" fn(
            fs: *mut TSK_FS_INFO,
            fs_file: *mut TSK_FS_FILE,
            addr: TSK_INUM_T,
        ) -> u8,
    >,
    #[doc = "< \\internal"]
    pub get_default_attr_type: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const TSK_FS_FILE) -> TSK_FS_ATTR_TYPE_ENUM,
    >,
    #[doc = "< \\internal"]
    pub load_attrs: ::std::option::Option<unsafe extern "C" fn(arg1: *mut TSK_FS_FILE) -> u8>,
    #[doc = "< \\internal"]
    pub decrypt_block: ::std::option::Option<
        unsafe extern "C" fn(
            fs: *mut TSK_FS_INFO,
            start: TSK_DADDR_T,
            data: *mut ::std::os::raw::c_void,
        ) -> u8,
    >,
    #[doc = " Pointer to file system specific function that prints details on a specific file to a file handle.\n\n @param fs File system file is located in\n @param hFile File handle to print text to\n @param inum Address of file in file system\n @param numblock The number of blocks in file to force print (can go beyond file size)\n @param sec_skew Clock skew in seconds to also print times in\n\n @returns 1 on error and 0 on success"]
    pub istat: ::std::option::Option<
        unsafe extern "C" fn(
            fs: *mut TSK_FS_INFO,
            flags: TSK_FS_ISTAT_FLAG_ENUM,
            hFile: *mut FILE,
            inum: TSK_INUM_T,
            numblock: TSK_DADDR_T,
            sec_skew: i32,
        ) -> u8,
    >,
    #[doc = "< \\internal Call tsk_fs_dir_open_meta() instead."]
    pub dir_open_meta: ::std::option::Option<
        unsafe extern "C" fn(
            fs: *mut TSK_FS_INFO,
            a_fs_dir: *mut *mut TSK_FS_DIR,
            inode: TSK_INUM_T,
            recursion_depth: ::std::os::raw::c_int,
        ) -> TSK_RETVAL_ENUM,
    >,
    #[doc = "< \\internal"]
    pub jopen:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut TSK_FS_INFO, arg2: TSK_INUM_T) -> u8>,
    #[doc = "< \\internal"]
    pub jblk_walk: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TSK_FS_INFO,
            arg2: TSK_DADDR_T,
            arg3: TSK_DADDR_T,
            arg4: ::std::os::raw::c_int,
            arg5: TSK_FS_JBLK_WALK_CB,
            arg6: *mut ::std::os::raw::c_void,
        ) -> u8,
    >,
    #[doc = "< \\internal"]
    pub jentry_walk: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TSK_FS_INFO,
            arg2: ::std::os::raw::c_int,
            arg3: TSK_FS_JENTRY_WALK_CB,
            arg4: *mut ::std::os::raw::c_void,
        ) -> u8,
    >,
    #[doc = "< \\internal"]
    pub fsstat:
        ::std::option::Option<unsafe extern "C" fn(fs: *mut TSK_FS_INFO, hFile: *mut FILE) -> u8>,
    #[doc = "< \\internal"]
    pub name_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TSK_FS_INFO,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< \\internal"]
    pub fscheck:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut TSK_FS_INFO, arg2: *mut FILE) -> u8>,
    #[doc = "< FS-specific function: Call tsk_fs_close() instead."]
    pub close: ::std::option::Option<unsafe extern "C" fn(fs: *mut TSK_FS_INFO)>,
    pub fread_owner_sid: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut TSK_FS_FILE, arg2: *mut *mut ::std::os::raw::c_char) -> u8,
    >,
    #[doc = "< \\internal pointer to specific implementation"]
    pub impl_: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_FS_INFO__bindgen_ty_1 {
    #[doc = "< Pointer to the image layer state"]
    pub img_info: *mut TSK_IMG_INFO,
    #[doc = "< Byte offset into img_info that fs starts"]
    pub offset: TSK_OFF_T,
}
unsafe extern "C" {
    pub fn tsk_fs_open_img(
        arg1: *mut TSK_IMG_INFO,
        arg2: TSK_OFF_T,
        arg3: TSK_FS_TYPE_ENUM,
    ) -> *mut TSK_FS_INFO;
}
unsafe extern "C" {
    pub fn tsk_fs_open_vol(
        arg1: *const TSK_VS_PART_INFO,
        arg2: TSK_FS_TYPE_ENUM,
    ) -> *mut TSK_FS_INFO;
}
unsafe extern "C" {
    pub fn tsk_fs_open_pool(
        arg1: *const TSK_POOL_INFO,
        arg2: TSK_DADDR_T,
        arg3: TSK_FS_TYPE_ENUM,
    ) -> *mut TSK_FS_INFO;
}
unsafe extern "C" {
    pub fn tsk_fs_open_img_decrypt(
        arg1: *mut TSK_IMG_INFO,
        arg2: TSK_OFF_T,
        arg3: TSK_FS_TYPE_ENUM,
        password: *const ::std::os::raw::c_char,
    ) -> *mut TSK_FS_INFO;
}
unsafe extern "C" {
    pub fn tsk_fs_open_vol_decrypt(
        arg1: *const TSK_VS_PART_INFO,
        arg2: TSK_FS_TYPE_ENUM,
        password: *const ::std::os::raw::c_char,
    ) -> *mut TSK_FS_INFO;
}
unsafe extern "C" {
    pub fn tsk_fs_open_pool_decrypt(
        arg1: *const TSK_POOL_INFO,
        arg2: TSK_DADDR_T,
        arg3: TSK_FS_TYPE_ENUM,
        password: *const ::std::os::raw::c_char,
    ) -> *mut TSK_FS_INFO;
}
unsafe extern "C" {
    pub fn tsk_fs_close(arg1: *mut TSK_FS_INFO);
}
unsafe extern "C" {
    pub fn tsk_fs_type_toid_utf8(arg1: *const ::std::os::raw::c_char) -> TSK_FS_TYPE_ENUM;
}
unsafe extern "C" {
    pub fn tsk_fs_type_toid(arg1: *const TSK_TCHAR) -> TSK_FS_TYPE_ENUM;
}
unsafe extern "C" {
    pub fn tsk_fs_type_print(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn tsk_fs_type_toname(arg1: TSK_FS_TYPE_ENUM) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tsk_fs_type_supported() -> TSK_FS_TYPE_ENUM;
}
unsafe extern "C" {
    pub fn tsk_fs_get_encryption_description(
        a_fs_info: *mut TSK_FS_INFO,
        a_desc: *mut ::std::os::raw::c_char,
        a_descLen: usize,
    );
}
unsafe extern "C" {
    pub fn tsk_fs_read(
        a_fs: *mut TSK_FS_INFO,
        a_off: TSK_OFF_T,
        a_buf: *mut ::std::os::raw::c_char,
        a_len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn tsk_fs_read_decrypt(
        a_fs: *mut TSK_FS_INFO,
        a_off: TSK_OFF_T,
        a_buf: *mut ::std::os::raw::c_char,
        a_len: usize,
        crypto_id: TSK_DADDR_T,
    ) -> isize;
}
unsafe extern "C" {
    pub fn tsk_fs_read_block(
        a_fs: *mut TSK_FS_INFO,
        a_addr: TSK_DADDR_T,
        a_buf: *mut ::std::os::raw::c_char,
        a_len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn tsk_fs_read_block_decrypt(
        a_fs: *mut TSK_FS_INFO,
        a_addr: TSK_DADDR_T,
        a_buf: *mut ::std::os::raw::c_char,
        a_len: usize,
        crypto_id: TSK_DADDR_T,
    ) -> isize;
}
pub const TSK_FS_BLKCALC_FLAG_ENUM_TSK_FS_BLKCALC_DD: TSK_FS_BLKCALC_FLAG_ENUM = 1;
pub const TSK_FS_BLKCALC_FLAG_ENUM_TSK_FS_BLKCALC_BLKLS: TSK_FS_BLKCALC_FLAG_ENUM = 2;
pub const TSK_FS_BLKCALC_FLAG_ENUM_TSK_FS_BLKCALC_SLACK: TSK_FS_BLKCALC_FLAG_ENUM = 4;
#[doc = " LIBRARY ROUTINES FOR COMMAND LINE FUNCTIONS"]
pub type TSK_FS_BLKCALC_FLAG_ENUM = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn tsk_fs_blkcalc(
        fs: *mut TSK_FS_INFO,
        flags: TSK_FS_BLKCALC_FLAG_ENUM,
        cnt: TSK_DADDR_T,
    ) -> i8;
}
pub const TSK_FS_BLKCAT_FLAG_ENUM_TSK_FS_BLKCAT_NONE: TSK_FS_BLKCAT_FLAG_ENUM = 0;
pub const TSK_FS_BLKCAT_FLAG_ENUM_TSK_FS_BLKCAT_HEX: TSK_FS_BLKCAT_FLAG_ENUM = 1;
pub const TSK_FS_BLKCAT_FLAG_ENUM_TSK_FS_BLKCAT_ASCII: TSK_FS_BLKCAT_FLAG_ENUM = 2;
pub const TSK_FS_BLKCAT_FLAG_ENUM_TSK_FS_BLKCAT_HTML: TSK_FS_BLKCAT_FLAG_ENUM = 4;
pub const TSK_FS_BLKCAT_FLAG_ENUM_TSK_FS_BLKCAT_STAT: TSK_FS_BLKCAT_FLAG_ENUM = 8;
pub type TSK_FS_BLKCAT_FLAG_ENUM = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn tsk_fs_blkcat(
        fs: *mut TSK_FS_INFO,
        flags: TSK_FS_BLKCAT_FLAG_ENUM,
        addr: TSK_DADDR_T,
        read_num_units: TSK_DADDR_T,
    ) -> u8;
}
pub const TSK_FS_BLKLS_FLAG_ENUM_TSK_FS_BLKLS_NONE: TSK_FS_BLKLS_FLAG_ENUM = 0;
pub const TSK_FS_BLKLS_FLAG_ENUM_TSK_FS_BLKLS_CAT: TSK_FS_BLKLS_FLAG_ENUM = 1;
pub const TSK_FS_BLKLS_FLAG_ENUM_TSK_FS_BLKLS_LIST: TSK_FS_BLKLS_FLAG_ENUM = 2;
pub const TSK_FS_BLKLS_FLAG_ENUM_TSK_FS_BLKLS_SLACK: TSK_FS_BLKLS_FLAG_ENUM = 4;
pub type TSK_FS_BLKLS_FLAG_ENUM = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn tsk_fs_blkls(
        fs: *mut TSK_FS_INFO,
        lclflags: TSK_FS_BLKLS_FLAG_ENUM,
        bstart: TSK_DADDR_T,
        bend: TSK_DADDR_T,
        flags: TSK_FS_BLOCK_WALK_FLAG_ENUM,
    ) -> u8;
}
unsafe extern "C" {
    pub fn tsk_fs_blkstat(fs: *mut TSK_FS_INFO, addr: TSK_DADDR_T) -> u8;
}
pub const TSK_FS_FFIND_FLAG_ENUM_TSK_FS_FFIND_ALL: TSK_FS_FFIND_FLAG_ENUM = 1;
pub type TSK_FS_FFIND_FLAG_ENUM = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn tsk_fs_ffind(
        fs: *mut TSK_FS_INFO,
        lclflags: TSK_FS_FFIND_FLAG_ENUM,
        inode: TSK_INUM_T,
        type_: TSK_FS_ATTR_TYPE_ENUM,
        type_used: u8,
        id: u16,
        id_used: u8,
        flags: TSK_FS_DIR_WALK_FLAG_ENUM,
    ) -> u8;
}
pub const TSK_FS_FLS_FLAG_ENUM_TSK_FS_FLS_NONE: TSK_FS_FLS_FLAG_ENUM = 0;
pub const TSK_FS_FLS_FLAG_ENUM_TSK_FS_FLS_DOT: TSK_FS_FLS_FLAG_ENUM = 1;
pub const TSK_FS_FLS_FLAG_ENUM_TSK_FS_FLS_LONG: TSK_FS_FLS_FLAG_ENUM = 2;
pub const TSK_FS_FLS_FLAG_ENUM_TSK_FS_FLS_FILE: TSK_FS_FLS_FLAG_ENUM = 4;
pub const TSK_FS_FLS_FLAG_ENUM_TSK_FS_FLS_DIR: TSK_FS_FLS_FLAG_ENUM = 8;
pub const TSK_FS_FLS_FLAG_ENUM_TSK_FS_FLS_FULL: TSK_FS_FLS_FLAG_ENUM = 16;
pub const TSK_FS_FLS_FLAG_ENUM_TSK_FS_FLS_MAC: TSK_FS_FLS_FLAG_ENUM = 32;
pub const TSK_FS_FLS_FLAG_ENUM_TSK_FS_FLS_HASH: TSK_FS_FLS_FLAG_ENUM = 64;
pub type TSK_FS_FLS_FLAG_ENUM = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn tsk_fs_fls(
        fs: *mut TSK_FS_INFO,
        lclflags: TSK_FS_FLS_FLAG_ENUM,
        inode: TSK_INUM_T,
        flags: TSK_FS_DIR_WALK_FLAG_ENUM,
        pre: *const TSK_TCHAR,
        skew: i32,
    ) -> u8;
}
unsafe extern "C" {
    pub fn tsk_fs_icat(
        fs: *mut TSK_FS_INFO,
        inum: TSK_INUM_T,
        type_: TSK_FS_ATTR_TYPE_ENUM,
        type_used: u8,
        id: u16,
        id_used: u8,
        flags: TSK_FS_FILE_WALK_FLAG_ENUM,
    ) -> u8;
}
pub const TSK_FS_IFIND_FLAG_ENUM_TSK_FS_IFIND_NONE: TSK_FS_IFIND_FLAG_ENUM = 0;
pub const TSK_FS_IFIND_FLAG_ENUM_TSK_FS_IFIND_ALL: TSK_FS_IFIND_FLAG_ENUM = 1;
pub const TSK_FS_IFIND_FLAG_ENUM_TSK_FS_IFIND_PAR_LONG: TSK_FS_IFIND_FLAG_ENUM = 2;
pub type TSK_FS_IFIND_FLAG_ENUM = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn tsk_fs_ifind_path(
        fs: *mut TSK_FS_INFO,
        path: *mut TSK_TCHAR,
        result: *mut TSK_INUM_T,
    ) -> i8;
}
unsafe extern "C" {
    pub fn tsk_fs_ifind_data(
        fs: *mut TSK_FS_INFO,
        flags: TSK_FS_IFIND_FLAG_ENUM,
        blk: TSK_DADDR_T,
    ) -> u8;
}
unsafe extern "C" {
    pub fn tsk_fs_ifind_par(
        fs: *mut TSK_FS_INFO,
        flags: TSK_FS_IFIND_FLAG_ENUM,
        par: TSK_INUM_T,
    ) -> u8;
}
pub const TSK_FS_ILS_FLAG_ENUM_TSK_FS_ILS_NONE: TSK_FS_ILS_FLAG_ENUM = 0;
pub const TSK_FS_ILS_FLAG_ENUM_TSK_FS_ILS_OPEN: TSK_FS_ILS_FLAG_ENUM = 1;
pub const TSK_FS_ILS_FLAG_ENUM_TSK_FS_ILS_MAC: TSK_FS_ILS_FLAG_ENUM = 2;
pub const TSK_FS_ILS_FLAG_ENUM_TSK_FS_ILS_LINK: TSK_FS_ILS_FLAG_ENUM = 4;
pub const TSK_FS_ILS_FLAG_ENUM_TSK_FS_ILS_UNLINK: TSK_FS_ILS_FLAG_ENUM = 8;
pub type TSK_FS_ILS_FLAG_ENUM = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn tsk_fs_ils(
        fs: *mut TSK_FS_INFO,
        lclflags: TSK_FS_ILS_FLAG_ENUM,
        istart: TSK_INUM_T,
        ilast: TSK_INUM_T,
        flags: TSK_FS_META_FLAG_ENUM,
        skew: i32,
        img: *const TSK_TCHAR,
    ) -> u8;
}
unsafe extern "C" {
    pub fn tsk_fs_parse_inum(
        str_: *const TSK_TCHAR,
        arg1: *mut TSK_INUM_T,
        arg2: *mut TSK_FS_ATTR_TYPE_ENUM,
        arg3: *mut u8,
        arg4: *mut u16,
        arg5: *mut u8,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Quickly return if hash is found (do not return file name etc.)"]
pub const TSK_HDB_FLAG_ENUM_TSK_HDB_FLAG_QUICK: TSK_HDB_FLAG_ENUM = 1;
#[doc = "< Return other details besides only file name (not used"]
pub const TSK_HDB_FLAG_ENUM_TSK_HDB_FLAG_EXT: TSK_HDB_FLAG_ENUM = 2;
#[doc = " Flags used for lookups"]
pub type TSK_HDB_FLAG_ENUM = ::std::os::raw::c_int;
#[doc = "< Invalid algorithm signals error."]
pub const TSK_HDB_HTYPE_ENUM_TSK_HDB_HTYPE_INVALID_ID: TSK_HDB_HTYPE_ENUM = 0;
#[doc = "< MD5 Algorithm"]
pub const TSK_HDB_HTYPE_ENUM_TSK_HDB_HTYPE_MD5_ID: TSK_HDB_HTYPE_ENUM = 1;
#[doc = "< SHA1 Algorithm"]
pub const TSK_HDB_HTYPE_ENUM_TSK_HDB_HTYPE_SHA1_ID: TSK_HDB_HTYPE_ENUM = 2;
#[doc = "< SHA2-256 (aka SHA-256) Algorithm"]
pub const TSK_HDB_HTYPE_ENUM_TSK_HDB_HTYPE_SHA2_256_ID: TSK_HDB_HTYPE_ENUM = 4;
#[doc = " Hash algorithm types"]
pub type TSK_HDB_HTYPE_ENUM = ::std::os::raw::c_int;
#[doc = "< Invalid type signals error."]
pub const TSK_HDB_DBTYPE_ENUM_TSK_HDB_DBTYPE_INVALID_ID: TSK_HDB_DBTYPE_ENUM = 0;
#[doc = "< NIST NSRL format"]
pub const TSK_HDB_DBTYPE_ENUM_TSK_HDB_DBTYPE_NSRL_ID: TSK_HDB_DBTYPE_ENUM = 1;
#[doc = "< md5sum format"]
pub const TSK_HDB_DBTYPE_ENUM_TSK_HDB_DBTYPE_MD5SUM_ID: TSK_HDB_DBTYPE_ENUM = 2;
#[doc = "< hashkeeper format"]
pub const TSK_HDB_DBTYPE_ENUM_TSK_HDB_DBTYPE_HK_ID: TSK_HDB_DBTYPE_ENUM = 3;
#[doc = "< Only the database index was opened -- original dbtype is unknown"]
pub const TSK_HDB_DBTYPE_ENUM_TSK_HDB_DBTYPE_IDXONLY_ID: TSK_HDB_DBTYPE_ENUM = 4;
#[doc = "< EnCase format"]
pub const TSK_HDB_DBTYPE_ENUM_TSK_HDB_DBTYPE_ENCASE_ID: TSK_HDB_DBTYPE_ENUM = 5;
#[doc = "< SQLite format"]
pub const TSK_HDB_DBTYPE_ENUM_TSK_HDB_DBTYPE_SQLITE_ID: TSK_HDB_DBTYPE_ENUM = 6;
#[doc = " Hash Database types"]
pub type TSK_HDB_DBTYPE_ENUM = ::std::os::raw::c_int;
pub type TSK_HDB_LOOKUP_FN = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut TSK_HDB_INFO,
        hash: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
    ) -> TSK_WALK_RET_ENUM,
>;
#[doc = " Represents an open hash database. Instances are created using the\n tsk_hdb_open() API and are passed to hash database API functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_HDB_INFO {
    #[doc = "< Database file path, may be NULL for an index only database"]
    pub db_fname: *mut TSK_TCHAR,
    #[doc = "< Name of the database, for callbacks"]
    pub db_name: [::std::os::raw::c_char; 512usize],
    #[doc = "< Type of database"]
    pub db_type: TSK_HDB_DBTYPE_ENUM,
    #[doc = "< Lock for lazy loading and idx_lbuf"]
    pub lock: tsk_lock_t,
    #[doc = "< Flag set and unset when transaction are begun and ended"]
    pub transaction_in_progress: u8,
    pub get_db_path:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut TSK_HDB_INFO) -> *const TSK_TCHAR>,
    pub get_display_name: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut TSK_HDB_INFO) -> *const ::std::os::raw::c_char,
    >,
    pub uses_external_indexes: ::std::option::Option<unsafe extern "C" fn() -> u8>,
    pub get_index_path: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut TSK_HDB_INFO, arg2: TSK_HDB_HTYPE_ENUM) -> *const TSK_TCHAR,
    >,
    pub has_index: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut TSK_HDB_INFO, arg2: TSK_HDB_HTYPE_ENUM) -> u8,
    >,
    pub make_index: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut TSK_HDB_INFO, arg2: *mut TSK_TCHAR) -> u8,
    >,
    pub open_index: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut TSK_HDB_INFO, arg2: TSK_HDB_HTYPE_ENUM) -> u8,
    >,
    pub lookup_str: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TSK_HDB_INFO,
            arg2: *const ::std::os::raw::c_char,
            arg3: TSK_HDB_FLAG_ENUM,
            arg4: TSK_HDB_LOOKUP_FN,
            arg5: *mut ::std::os::raw::c_void,
        ) -> i8,
    >,
    pub lookup_raw: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TSK_HDB_INFO,
            arg2: *mut u8,
            arg3: u8,
            arg4: TSK_HDB_FLAG_ENUM,
            arg5: TSK_HDB_LOOKUP_FN,
            arg6: *mut ::std::os::raw::c_void,
        ) -> i8,
    >,
    pub lookup_verbose_str: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TSK_HDB_INFO,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_void,
        ) -> i8,
    >,
    pub accepts_updates: ::std::option::Option<unsafe extern "C" fn() -> u8>,
    pub add_entry: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TSK_HDB_INFO,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: *const ::std::os::raw::c_char,
            arg6: *const ::std::os::raw::c_char,
        ) -> u8,
    >,
    pub begin_transaction:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut TSK_HDB_INFO) -> u8>,
    pub commit_transaction:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut TSK_HDB_INFO) -> u8>,
    pub rollback_transaction:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut TSK_HDB_INFO) -> u8>,
    pub close_db: ::std::option::Option<unsafe extern "C" fn(arg1: *mut TSK_HDB_INFO)>,
}
#[doc = " Represents a text-format hash database (NSRL, EnCase, etc.) with the TSK binary search index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSK_HDB_BINSRCH_INFO {
    pub base: TSK_HDB_INFO,
    #[doc = "< File handle to database (always open)"]
    pub hDb: *mut FILE,
    #[doc = "< \\internal Database-specific function to find entry at a given offset"]
    pub get_entry: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TSK_HDB_INFO,
            arg2: *const ::std::os::raw::c_char,
            arg3: TSK_OFF_T,
            arg4: TSK_HDB_FLAG_ENUM,
            arg5: TSK_HDB_LOOKUP_FN,
            arg6: *mut ::std::os::raw::c_void,
        ) -> u8,
    >,
    #[doc = "< Type of hash used in currently open index"]
    pub hash_type: TSK_HDB_HTYPE_ENUM,
    #[doc = "< Length of hash used in currently open index"]
    pub hash_len: u16,
    #[doc = "< Name of index file, may be NULL for database without external index"]
    pub idx_fname: *mut TSK_TCHAR,
    #[doc = "< File handle to index (only open during lookups)"]
    pub hIdx: *mut FILE,
    #[doc = "< File handle to temp (unsorted) index file (only open during index creation)"]
    pub hIdxTmp: *mut FILE,
    #[doc = "< Name of unsorted index file"]
    pub uns_fname: *mut TSK_TCHAR,
    #[doc = "< Size of index file"]
    pub idx_size: TSK_OFF_T,
    #[doc = "< Offset in index file to first index entry"]
    pub idx_off: u16,
    #[doc = "< Length of each line in index"]
    pub idx_llen: usize,
    #[doc = "< Buffer to hold a line from the index  (r/w shared - lock)"]
    pub idx_lbuf: *mut ::std::os::raw::c_char,
    #[doc = "< Name of index of index file, may be NULL"]
    pub idx_idx_fname: *mut TSK_TCHAR,
    #[doc = "< Maps the first three bytes of a hash value to an offset in the index file"]
    pub idx_offsets: *mut u64,
}
#[doc = "< No special flags"]
pub const TSK_HDB_OPEN_ENUM_TSK_HDB_OPEN_NONE: TSK_HDB_OPEN_ENUM = 0;
#[doc = "< Open only the index -- do not look for the original DB"]
pub const TSK_HDB_OPEN_ENUM_TSK_HDB_OPEN_IDXONLY: TSK_HDB_OPEN_ENUM = 1;
#[doc = " Options for opening a hash database"]
pub type TSK_HDB_OPEN_ENUM = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn tsk_hdb_create(arg1: *mut TSK_TCHAR) -> u8;
}
unsafe extern "C" {
    pub fn tsk_hdb_open(arg1: *mut TSK_TCHAR, arg2: TSK_HDB_OPEN_ENUM) -> *mut TSK_HDB_INFO;
}
unsafe extern "C" {
    pub fn tsk_hdb_get_db_path(hdb_info: *mut TSK_HDB_INFO) -> *const TSK_TCHAR;
}
unsafe extern "C" {
    pub fn tsk_hdb_get_display_name(hdb_info: *mut TSK_HDB_INFO) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tsk_hdb_is_idx_only(arg1: *mut TSK_HDB_INFO) -> u8;
}
unsafe extern "C" {
    pub fn tsk_hdb_uses_external_indexes(arg1: *mut TSK_HDB_INFO) -> u8;
}
unsafe extern "C" {
    pub fn tsk_hdb_has_idx(hdb_info: *mut TSK_HDB_INFO, arg1: TSK_HDB_HTYPE_ENUM) -> u8;
}
unsafe extern "C" {
    pub fn tsk_hdb_make_index(arg1: *mut TSK_HDB_INFO, arg2: *mut TSK_TCHAR) -> u8;
}
unsafe extern "C" {
    pub fn tsk_hdb_get_idx_path(
        arg1: *mut TSK_HDB_INFO,
        arg2: TSK_HDB_HTYPE_ENUM,
    ) -> *const TSK_TCHAR;
}
unsafe extern "C" {
    pub fn tsk_hdb_open_idx(arg1: *mut TSK_HDB_INFO, arg2: TSK_HDB_HTYPE_ENUM) -> u8;
}
unsafe extern "C" {
    pub fn tsk_hdb_lookup_str(
        arg1: *mut TSK_HDB_INFO,
        arg2: *const ::std::os::raw::c_char,
        arg3: TSK_HDB_FLAG_ENUM,
        arg4: TSK_HDB_LOOKUP_FN,
        arg5: *mut ::std::os::raw::c_void,
    ) -> i8;
}
unsafe extern "C" {
    pub fn tsk_hdb_lookup_raw(
        arg1: *mut TSK_HDB_INFO,
        arg2: *mut u8,
        arg3: u8,
        arg4: TSK_HDB_FLAG_ENUM,
        arg5: TSK_HDB_LOOKUP_FN,
        arg6: *mut ::std::os::raw::c_void,
    ) -> i8;
}
unsafe extern "C" {
    pub fn tsk_hdb_lookup_verbose_str(
        arg1: *mut TSK_HDB_INFO,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    ) -> i8;
}
unsafe extern "C" {
    pub fn tsk_hdb_accepts_updates(arg1: *mut TSK_HDB_INFO) -> u8;
}
unsafe extern "C" {
    pub fn tsk_hdb_add_entry(
        arg1: *mut TSK_HDB_INFO,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *const ::std::os::raw::c_char,
    ) -> u8;
}
unsafe extern "C" {
    pub fn tsk_hdb_begin_transaction(arg1: *mut TSK_HDB_INFO) -> u8;
}
unsafe extern "C" {
    pub fn tsk_hdb_commit_transaction(arg1: *mut TSK_HDB_INFO) -> u8;
}
unsafe extern "C" {
    pub fn tsk_hdb_rollback_transaction(arg1: *mut TSK_HDB_INFO) -> u8;
}
unsafe extern "C" {
    pub fn tsk_hdb_close(arg1: *mut TSK_HDB_INFO);
}
#[doc = "< Use autodetection methods"]
pub const TSK_POOL_TYPE_ENUM_TSK_POOL_TYPE_DETECT: TSK_POOL_TYPE_ENUM = 0;
#[doc = "< APFS Pooled Volumes"]
pub const TSK_POOL_TYPE_ENUM_TSK_POOL_TYPE_APFS: TSK_POOL_TYPE_ENUM = 1;
#[doc = "< Linux LVM volume group"]
pub const TSK_POOL_TYPE_ENUM_TSK_POOL_TYPE_LVM: TSK_POOL_TYPE_ENUM = 2;
#[doc = "< Unsupported pool container type"]
pub const TSK_POOL_TYPE_ENUM_TSK_POOL_TYPE_UNSUPP: TSK_POOL_TYPE_ENUM = 65535;
pub type TSK_POOL_TYPE_ENUM = ::std::os::raw::c_int;
pub const TSK_POOL_VOLUME_FLAGS_TSK_POOL_VOLUME_FLAG_ENCRYPTED: TSK_POOL_VOLUME_FLAGS = 1;
pub const TSK_POOL_VOLUME_FLAGS_TSK_POOL_VOLUME_FLAG_CASE_SENSITIVE: TSK_POOL_VOLUME_FLAGS = 2;
pub type TSK_POOL_VOLUME_FLAGS = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TSK_POOL_VOLUME_INFO {
    #[doc = "< Set to TSK_POOL_VOLUME_INFO_TAG when struct is alloc"]
    pub tag: u32,
    #[doc = "< Index of Volume"]
    pub index: ::std::os::raw::c_int,
    #[doc = "< Description"]
    pub desc: *mut ::std::os::raw::c_char,
    #[doc = "< Password hint for encrypted volumes"]
    pub password_hint: *mut ::std::os::raw::c_char,
    #[doc = "< Starting Block number"]
    pub block: u64,
    #[doc = "< Number of blocks in the volume"]
    pub num_blocks: u64,
    #[doc = "< Next Volume"]
    pub next: *mut _TSK_POOL_VOLUME_INFO,
    #[doc = "< Previous Volume"]
    pub prev: *mut _TSK_POOL_VOLUME_INFO,
    pub flags: TSK_POOL_VOLUME_FLAGS,
}
pub type TSK_POOL_VOLUME_INFO = _TSK_POOL_VOLUME_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TSK_POOL_INFO {
    #[doc = "< Set to TSK_POOL_INFO_TAG when struct is alloc"]
    pub tag: u32,
    #[doc = "< Type of pool container"]
    pub ctype: TSK_POOL_TYPE_ENUM,
    #[doc = "< Block size"]
    pub block_size: u32,
    #[doc = "< Number of blocks"]
    pub num_blocks: u64,
    #[doc = "< Number of volumes"]
    pub num_vols: ::std::os::raw::c_int,
    #[doc = "< The image offset of the pool"]
    pub img_offset: u64,
    #[doc = "< Linked list of volume info structs"]
    pub vol_list: *mut TSK_POOL_VOLUME_INFO,
    #[doc = "< \\internal"]
    pub close: ::std::option::Option<unsafe extern "C" fn(arg1: *const _TSK_POOL_INFO)>,
    pub poolstat: ::std::option::Option<
        unsafe extern "C" fn(pool: *const _TSK_POOL_INFO, hFile: *mut FILE) -> u8,
    >,
    pub get_img_info: ::std::option::Option<
        unsafe extern "C" fn(
            pool: *const _TSK_POOL_INFO,
            pvol_block: TSK_DADDR_T,
        ) -> *mut TSK_IMG_INFO,
    >,
    #[doc = "< \\internal Implementation specific pointer"]
    pub impl_: *mut ::std::os::raw::c_void,
}
unsafe extern "C" {
    pub fn tsk_pool_open_sing(
        part: *const TSK_VS_PART_INFO,
        type_: TSK_POOL_TYPE_ENUM,
    ) -> *const TSK_POOL_INFO;
}
unsafe extern "C" {
    pub fn tsk_pool_open(
        num_vols: ::std::os::raw::c_int,
        parts: *const *const TSK_VS_PART_INFO,
        type_: TSK_POOL_TYPE_ENUM,
    ) -> *const TSK_POOL_INFO;
}
unsafe extern "C" {
    pub fn tsk_pool_open_img_sing(
        img: *mut TSK_IMG_INFO,
        offset: TSK_OFF_T,
        type_: TSK_POOL_TYPE_ENUM,
    ) -> *const TSK_POOL_INFO;
}
unsafe extern "C" {
    pub fn tsk_pool_open_img(
        num_imgs: ::std::os::raw::c_int,
        imgs: *const *mut TSK_IMG_INFO,
        offsets: *const TSK_OFF_T,
        type_: TSK_POOL_TYPE_ENUM,
    ) -> *const TSK_POOL_INFO;
}
unsafe extern "C" {
    pub fn tsk_pool_close(arg1: *const TSK_POOL_INFO);
}
unsafe extern "C" {
    pub fn tsk_pool_read(
        a_fs: *mut TSK_POOL_INFO,
        a_off: TSK_OFF_T,
        a_buf: *mut ::std::os::raw::c_char,
        a_len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn tsk_pool_unallocated_runs(arg1: *const TSK_POOL_INFO) -> *mut TSK_FS_ATTR_RUN;
}
unsafe extern "C" {
    pub fn tsk_pool_type_toid(str_: *const TSK_TCHAR) -> TSK_POOL_TYPE_ENUM;
}
unsafe extern "C" {
    pub fn tsk_pool_type_toid_utf8(str_: *const ::std::os::raw::c_char) -> TSK_POOL_TYPE_ENUM;
}
unsafe extern "C" {
    pub fn tsk_pool_type_print(hFile: *mut FILE);
}
unsafe extern "C" {
    pub fn tsk_pool_type_toname(ptype: TSK_POOL_TYPE_ENUM) -> *const ::std::os::raw::c_char;
}
